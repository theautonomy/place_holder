// Main demonstration class
public class CallbackInterfaceDemo {
    
    // 1. Basic callback interface similar to RowMapper
    @FunctionalInterface
    public interface DataMapper<T> {
        T mapData(String[] row, int rowNumber);
    }
    
    // 2. File processor that uses callback interface
    @FunctionalInterface
    public interface FileProcessor<T> {
        T processLine(String line, int lineNumber);
    }
    
    // 3. Event handler callback interface
    @FunctionalInterface
    public interface EventHandler<T> {
        void handleEvent(T event, long timestamp);
    }
    
    // Data processing service that uses callback pattern
    public static class DataProcessingService {
        
        // Method that accepts callback interface - similar to JdbcTemplate.query()
        public <T> java.util.List<T> processCSVData(String csvData, DataMapper<T> mapper) {
            java.util.List<T> results = new java.util.ArrayList<>();
            String[] lines = csvData.split("\n");
            
            for (int i = 0; i < lines.length; i++) {
                String[] row = lines[i].split(",");
                T mappedObject = mapper.mapData(row, i);
                if (mappedObject != null) {
                    results.add(mappedObject);
                }
            }
            return results;
        }
        
        // File processing with callback
        public <T> java.util.List<T> processFile(String fileContent, FileProcessor<T> processor) {
            java.util.List<T> results = new java.util.ArrayList<>();
            String[] lines = fileContent.split("\n");
            
            for (int i = 0; i < lines.length; i++) {
                T result = processor.processLine(lines[i], i + 1);
                if (result != null) {
                    results.add(result);
                }
            }
            return results;
        }
        
        // Event processing with callback
        public <T> void processEvents(java.util.List<T> events, EventHandler<T> handler) {
            long timestamp = System.currentTimeMillis();
            for (T event : events) {
                handler.handleEvent(event, timestamp++);
            }
        }
    }
    
    // Sample domain objects
    public static class Person {
        private String name;
        private int age;
        private String email;
        
        public Person(String name, int age, String email) {
            this.name = name;
            this.age = age;
            this.email = email;
        }
        
        // Getters
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getEmail() { return email; }
        
        @Override
        public String toString() {
            return String.format("Person{name='%s', age=%d, email='%s'}", name, age, email);
        }
    }
    
    public static class Product {
        private String name;
        private double price;
        private String category;
        
        public Product(String name, double price, String category) {
            this.name = name;
            this.price = price;
            this.category = category;
        }
        
        // Getters
        public String getName() { return name; }
        public double getPrice() { return price; }
        public String getCategory() { return category; }
        
        @Override
        public String toString() {
            return String.format("Product{name='%s', price=%.2f, category='%s'}", name, price, category);
        }
    }
    
    public static class LogEntry {
        private String level;
        private String message;
        private int lineNumber;
        
        public LogEntry(String level, String message, int lineNumber) {
            this.level = level;
            this.message = message;
            this.lineNumber = lineNumber;
        }
        
        @Override
        public String toString() {
            return String.format("LogEntry{level='%s', message='%s', line=%d}", level, message, lineNumber);
        }
    }
    
    public static void main(String[] args) {
        DataProcessingService service = new DataProcessingService();
        
        System.out.println("=== Callback Interface Pattern Demo ===\n");
        
        // Demo 1: CSV Data Processing with Anonymous Class (traditional approach)
        System.out.println("1. Processing CSV data with Anonymous Class:");
        String csvData = "John,25,john@email.com\nJane,30,jane@email.com\nBob,35,bob@email.com";
        
        java.util.List<Person> people = service.processCSVData(csvData, new DataMapper<Person>() {
            @Override
            public Person mapData(String[] row, int rowNumber) {
                if (row.length >= 3) {
                    return new Person(row[0], Integer.parseInt(row[1]), row[2]);
                }
                return null;
            }
        });
        
        people.forEach(System.out::println);
        
        // Demo 2: Lambda Expression (modern approach)
        System.out.println("\n2. Processing Product CSV with Lambda Expression:");
        String productData = "Laptop,999.99,Electronics\nBook,29.99,Education\nChair,199.99,Furniture";
        
        java.util.List<Product> products = service.processCSVData(productData, 
            (row, rowNum) -> row.length >= 3 ? 
                new Product(row[0], Double.parseDouble(row[1]), row[2]) : null
        );
        
        products.forEach(System.out::println);
        
        // Demo 3: Method Reference
        System.out.println("\n3. Processing with Method Reference:");
        java.util.List<String> upperCaseNames = service.processCSVData(csvData,
            CallbackInterfaceDemo::extractAndUpperCaseName
        );
        
        upperCaseNames.forEach(name -> System.out.println("Uppercase name: " + name));
        
        // Demo 4: File Processing Callback
        System.out.println("\n4. Log File Processing:");
        String logContent = "INFO: Application started\nERROR: Database connection failed\nWARN: Low memory detected";
        
        java.util.List<LogEntry> logEntries = service.processFile(logContent, (line, lineNum) -> {
            String[] parts = line.split(": ", 2);
            if (parts.length == 2) {
                return new LogEntry(parts[0], parts[1], lineNum);
            }
            return null;
        });
        
        logEntries.forEach(System.out::println);
        
        // Demo 5: Event Processing Callback
        System.out.println("\n5. Event Processing:");
        java.util.List<String> events = java.util.Arrays.asList("UserLogin", "FileUpload", "DataExport");
        
        service.processEvents(events, (event, timestamp) -> {
            System.out.println(String.format("Event: %s processed at timestamp: %d", event, timestamp));
        });
        
        // Demo 6: Complex processing with filtering
        System.out.println("\n6. Filtered Processing (Adults only):");
        java.util.List<Person> adults = service.processCSVData(csvData, (row, rowNum) -> {
            if (row.length >= 3) {
                int age = Integer.parseInt(row[1]);
                if (age >= 18) {  // Filter: only adults
                    return new Person(row[0], age, row[2]);
                }
            }
            return null;  // Skip non-adults
        });
        
        adults.forEach(person -> System.out.println("Adult: " + person));
        
        // Demo 7: Demonstrating the flexibility of callback pattern
        System.out.println("\n7. Multiple Processing Strategies:");
        
        // Strategy 1: Extract names only
        java.util.List<String> names = service.processCSVData(csvData, (row, rowNum) -> row[0]);
        System.out.println("Names: " + names);
        
        // Strategy 2: Extract ages only
        java.util.List<Integer> ages = service.processCSVData(csvData, (row, rowNum) -> Integer.parseInt(row[1]));
        System.out.println("Ages: " + ages);
        
        // Strategy 3: Create summary strings
        java.util.List<String> summaries = service.processCSVData(csvData, 
            (row, rowNum) -> String.format("Row %d: %s is %s years old", rowNum, row[0], row[1])
        );
        summaries.forEach(System.out::println);
        
        System.out.println("\n=== Demo Complete ===");
        System.out.println("\nKey Benefits of Callback Interface Pattern:");
        System.out.println("• Separation of concerns - processing logic vs mapping logic");
        System.out.println("• Reusability - same processing method, different mapping strategies");
        System.out.println("• Flexibility - can handle different data types and transformations");
        System.out.println("• Type safety - generic interfaces provide compile-time type checking");
        System.out.println("• Clean code - eliminates repetitive processing boilerplate");
    }
    
    // Helper method for method reference demo
    private static String extractAndUpperCaseName(String[] row, int rowNumber) {
        return row.length > 0 ? row[0].toUpperCase() : null;
    }
}

/* 
 * Additional example showing how Spring's RowMapper works conceptually:
 * 
 * // This is how you'd use Spring's RowMapper:
 * List<Person> people = jdbcTemplate.query(
 *     "SELECT name, age, email FROM persons", 
 *     new RowMapper<Person>() {
 *         @Override
 *         public Person mapRow(ResultSet rs, int rowNum) throws SQLException {
 *             return new Person(
 *                 rs.getString("name"),
 *                 rs.getInt("age"), 
 *                 rs.getString("email")
 *             );
 *         }
 *     }
 * );
 * 
 * // Or with lambda:
 * List<Person> people = jdbcTemplate.query(
 *     "SELECT name, age, email FROM persons",
 *     (rs, rowNum) -> new Person(rs.getString("name"), rs.getInt("age"), rs.getString("email"))
 * );
 */


I'll create a Java application that demonstrates the callback interface pattern using Spring JDBC's RowMapper as reference. This will show how callback interfaces work by creating a similar pattern for different scenarios.This Java application demonstrates the callback interface pattern using Spring JDBC's RowMapper as inspiration. Here's what the demo shows:

## Key Concepts Demonstrated:

1. **Callback Interface Definition**: Similar to RowMapper, I created `DataMapper<T>` that takes raw data and transforms it into objects.

2. **Separation of Concerns**: The processing logic (iterating through data) is separated from the mapping logic (how to convert each row).

3. **Multiple Implementation Approaches**:
   - Anonymous inner classes (traditional)
   - Lambda expressions (modern Java 8+)
   - Method references

4. **Generic Type Safety**: The interfaces use generics to ensure type safety at compile time.

5. **Reusability**: The same processing method can handle different data types and transformations.

## How It Maps to Spring's RowMapper:

- **Spring's RowMapper**: `T mapRow(ResultSet rs, int rowNum)`
- **Our DataMapper**: `T mapData(String[] row, int rowNumber)`

Both follow the same pattern:
1. Take raw data (ResultSet vs String array)
2. Transform it into a domain object
3. Return the transformed object
4. Let the framework handle iteration and collection

## Benefits Shown:

- **Flexibility**: Same processing code works for Person, Product, LogEntry, or any type
- **Clean Code**: No repetitive boilerplate for data processing
- **Type Safety**: Generics ensure compile-time type checking
- **Functional Programming**: Supports modern Java functional programming paradigms

The demo includes practical examples like CSV processing, log file parsing, and event handling - all using the same callback pattern that makes Spring JDBC so powerful and flexible.
