// 1. Custom PropertySourceFactory
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.support.DefaultPropertySourceFactory;
import org.springframework.core.io.support.EncodedResource;
import org.springframework.core.io.support.PropertySourceFactory;

import java.io.IOException;
import java.util.Properties;

public class CaseInsensitivePropertySourceFactory implements PropertySourceFactory {

    @Override
    public PropertySource<?> createPropertySource(String name, EncodedResource resource) throws IOException {
        // Use default factory to load properties first
        DefaultPropertySourceFactory defaultFactory = new DefaultPropertySourceFactory();
        PropertySource<?> defaultPropertySource = defaultFactory.createPropertySource(name, resource);
        
        // Create case-insensitive wrapper
        return new CaseInsensitivePropertySource(
            defaultPropertySource.getName(), 
            (Properties) defaultPropertySource.getSource()
        );
    }
}

// 2. Case-Insensitive PropertySource wrapper
import org.springframework.core.env.PropertiesPropertySource;
import java.util.Properties;

public class CaseInsensitivePropertySource extends PropertiesPropertySource {
    
    public CaseInsensitivePropertySource(String name, Properties source) {
        super(name, createCaseInsensitiveProperties(source));
    }
    
    private static Properties createCaseInsensitiveProperties(Properties original) {
        Properties caseInsensitive = new Properties() {
            @Override
            public String getProperty(String key) {
                // First try exact match
                String value = super.getProperty(key);
                if (value != null) {
                    return value;
                }
                
                // If not found, try case-insensitive search
                for (Object k : keySet()) {
                    if (k.toString().equalsIgnoreCase(key)) {
                        return super.getProperty(k.toString());
                    }
                }
                return null;
            }
            
            @Override
            public Object get(Object key) {
                if (key instanceof String) {
                    return getProperty((String) key);
                }
                return super.get(key);
            }
            
            @Override
            public boolean containsKey(Object key) {
                if (super.containsKey(key)) {
                    return true;
                }
                
                if (key instanceof String) {
                    String keyStr = (String) key;
                    for (Object k : keySet()) {
                        if (k.toString().equalsIgnoreCase(keyStr)) {
                            return true;
                        }
                    }
                }
                return false;
            }
        };
        
        // Copy all properties to the case-insensitive wrapper
        caseInsensitive.putAll(original);
        return caseInsensitive;
    }
}

// 3. Configuration class using the custom factory
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource(
    value = "classpath:application-custom.properties",
    factory = CaseInsensitivePropertySourceFactory.class
)
public class CaseInsensitivePropertyConfig {
    // Configuration class content
}

// 4. Example usage in a component
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class PropertyTestComponent {
    
    @Value("${database.URL:default}")  // Will match database.url case-insensitively
    private String databaseUrl;
    
    @Value("${SERVER.port:8080}")      // Will match server.port case-insensitively
    private int serverPort;
    
    private final Environment environment;
    
    public PropertyTestComponent(Environment environment) {
        this.environment = environment;
    }
    
    public void demonstrateUsage() {
        // These will all work regardless of case in the properties file
        String url1 = environment.getProperty("database.url");
        String url2 = environment.getProperty("DATABASE.URL"); 
        String url3 = environment.getProperty("Database.Url");
        
        System.out.println("database.url: " + url1);
        System.out.println("DATABASE.URL: " + url2);  
        System.out.println("Database.Url: " + url3);
        
        System.out.println("Injected values:");
        System.out.println("Database URL: " + databaseUrl);
        System.out.println("Server Port: " + serverPort);
    }
}

// 5. Alternative approach with @ConfigurationProperties
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "app")
@PropertySource(
    value = "classpath:app-config.properties",
    factory = CaseInsensitivePropertySourceFactory.class
)
public class AppProperties {
    
    private String name;
    private String version;
    private DatabaseConfig database = new DatabaseConfig();
    
    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }
    
    public DatabaseConfig getDatabase() { return database; }
    public void setDatabase(DatabaseConfig database) { this.database = database; }
    
    public static class DatabaseConfig {
        private String url;
        private String username;
        private String password;
        
        // Getters and setters
        public String getUrl() { return url; }
        public void setUrl(String url) { this.url = url; }
        
        public String getUsername() { return username; }
        public void setUsername(String username) { this.username = username; }
        
        public String getPassword() { return password; }
        public void setPassword(String password) { this.password = password; }
    }
}

// 6. Test class to demonstrate functionality
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class PropertyTestRunner implements CommandLineRunner {
    
    private final PropertyTestComponent testComponent;
    private final AppProperties appProperties;
    
    public PropertyTestRunner(PropertyTestComponent testComponent, AppProperties appProperties) {
        this.testComponent = testComponent;
        this.appProperties = appProperties;
    }
    
    @Override
    public void run(String... args) {
        System.out.println("=== Case-Insensitive Property Source Demo ===");
        
        testComponent.demonstrateUsage();
        
        System.out.println("\n=== Configuration Properties ===");
        System.out.println("App Name: " + appProperties.getName());
        System.out.println("App Version: " + appProperties.getVersion());
        System.out.println("DB URL: " + appProperties.getDatabase().getUrl());
        System.out.println("DB Username: " + appProperties.getDatabase().getUsername());
    }
}

///


# application-custom.properties
# These properties have mixed case intentionally
Database.URL=jdbc:mysql://localhost:3306/mydb
SERVER.port=9090
application.NAME=My Spring App
logging.LEVEL.root=INFO

# app-config.properties  
# Properties for @ConfigurationProperties example
APP.name=Case Insensitive App
app.VERSION=1.0.0
App.Database.Url=jdbc:postgresql://localhost:5432/appdb
app.database.USERNAME=admin
APP.DATABASE.password=secret123



\\\\\\\\\

// 1. Custom PropertySourceFactory for case-insensitive file loading
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.DefaultPropertySourceFactory;
import org.springframework.core.io.support.EncodedResource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.PropertySourceFactory;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.util.StringUtils;

import java.io.IOException;
import java.util.Arrays;
import java.util.Optional;

public class CaseInsensitiveFilenamePropertySourceFactory implements PropertySourceFactory {
    
    private final ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    private final DefaultPropertySourceFactory defaultFactory = new DefaultPropertySourceFactory();
    
    @Override
    public PropertySource<?> createPropertySource(String name, EncodedResource encodedResource) throws IOException {
        Resource resource = encodedResource.getResource();
        String originalPath = resource.getURI().toString();
        
        // If the resource exists as-is, use it directly
        if (resource.exists()) {
            return defaultFactory.createPropertySource(name, encodedResource);
        }
        
        // Try to find the file with case-insensitive matching
        Resource foundResource = findCaseInsensitiveResource(originalPath);
        if (foundResource != null && foundResource.exists()) {
            EncodedResource newEncodedResource = new EncodedResource(foundResource, 
                encodedResource.getEncoding(), encodedResource.getCharset());
            return defaultFactory.createPropertySource(name, newEncodedResource);
        }
        
        // If still not found, let the default factory handle it (will throw appropriate exception)
        return defaultFactory.createPropertySource(name, encodedResource);
    }
    
    private Resource findCaseInsensitiveResource(String originalPath) {
        try {
            // Extract directory and filename
            int lastSlash = originalPath.lastIndexOf('/');
            if (lastSlash == -1) {
                return null; // Can't handle relative paths without directory
            }
            
            String directory = originalPath.substring(0, lastSlash + 1);
            String filename = originalPath.substring(lastSlash + 1);
            
            // Remove any classpath: prefix for pattern matching
            String searchDirectory = directory;
            if (searchDirectory.startsWith("file:") || searchDirectory.startsWith("classpath:")) {
                // Handle different resource types
                if (searchDirectory.startsWith("classpath:")) {
                    searchDirectory = searchDirectory.substring("classpath:".length());
                }
            }
            
            // Create pattern to match all files in the directory
            String searchPattern = "classpath:" + searchDirectory + "*";
            
            Resource[] resources = resourceResolver.getResources(searchPattern);
            
            // Find matching file with case-insensitive comparison
            Optional<Resource> matchingResource = Arrays.stream(resources)
                .filter(r -> {
                    try {
                        String resourceFilename = r.getFilename();
                        return resourceFilename != null && 
                               resourceFilename.equalsIgnoreCase(filename);
                    } catch (Exception e) {
                        return false;
                    }
                })
                .findFirst();
                
            return matchingResource.orElse(null);
            
        } catch (Exception e) {
            // Log the exception in a real application
            System.err.println("Error during case-insensitive file search: " + e.getMessage());
            return null;
        }
    }
}

// 2. Enhanced version with file system support
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.ClassPathResource;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

public class EnhancedCaseInsensitivePropertySourceFactory implements PropertySourceFactory {
    
    private final DefaultPropertySourceFactory defaultFactory = new DefaultPropertySourceFactory();
    
    @Override
    public PropertySource<?> createPropertySource(String name, EncodedResource encodedResource) throws IOException {
        Resource resource = encodedResource.getResource();
        
        // If the resource exists as-is, use it directly
        if (resource.exists()) {
            return defaultFactory.createPropertySource(name, encodedResource);
        }
        
        // Try to find the file with case-insensitive matching
        Resource foundResource = findCaseInsensitiveResource(resource);
        if (foundResource != null && foundResource.exists()) {
            EncodedResource newEncodedResource = new EncodedResource(foundResource, 
                encodedResource.getEncoding(), encodedResource.getCharset());
            return defaultFactory.createPropertySource(name, newEncodedResource);
        }
        
        // If still not found, let the default factory handle it
        return defaultFactory.createPropertySource(name, encodedResource);
    }
    
    private Resource findCaseInsensitiveResource(Resource originalResource) {
        try {
            String description = originalResource.getDescription();
            
            if (description.contains("class path resource")) {
                return findCaseInsensitiveClassPathResource(originalResource);
            } else if (description.contains("file")) {
                return findCaseInsensitiveFileSystemResource(originalResource);
            }
            
        } catch (Exception e) {
            System.err.println("Error during case-insensitive file search: " + e.getMessage());
        }
        
        return null;
    }
    
    private Resource findCaseInsensitiveClassPathResource(Resource originalResource) {
        try {
            String description = originalResource.getDescription();
            // Extract path from description like "class path resource [config/APPLICATION.PROPERTIES]"
            int startBracket = description.indexOf('[');
            int endBracket = description.indexOf(']');
            
            if (startBracket != -1 && endBracket != -1) {
                String resourcePath = description.substring(startBracket + 1, endBracket);
                int lastSlash = resourcePath.lastIndexOf('/');
                
                String directory = lastSlash != -1 ? resourcePath.substring(0, lastSlash) : "";
                String filename = lastSlash != -1 ? resourcePath.substring(lastSlash + 1) : resourcePath;
                
                // Use ResourcePatternResolver to find all files in directory
                String pattern = StringUtils.hasText(directory) ? 
                    "classpath:" + directory + "/*" : "classpath:*";
                
                Resource[] resources = new PathMatchingResourcePatternResolver().getResources(pattern);
                
                for (Resource resource : resources) {
                    if (resource.getFilename() != null && 
                        resource.getFilename().equalsIgnoreCase(filename)) {
                        return resource;
                    }
                }
            }
        } catch (Exception e) {
            // Handle silently
        }
        
        return null;
    }
    
    private Resource findCaseInsensitiveFileSystemResource(Resource originalResource) {
        try {
            File originalFile = originalResource.getFile();
            File parentDir = originalFile.getParentFile();
            String targetFilename = originalFile.getName();
            
            if (parentDir != null && parentDir.exists() && parentDir.isDirectory()) {
                File[] files = parentDir.listFiles();
                if (files != null) {
                    for (File file : files) {
                        if (file.getName().equalsIgnoreCase(targetFilename)) {
                            return new FileSystemResource(file);
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Handle silently
        }
        
        return null;
    }
}

// 3. Configuration classes demonstrating usage
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@PropertySource(
    value = "classpath:APPLICATION.PROPERTIES",  // Will find application.properties
    factory = CaseInsensitiveFilenamePropertySourceFactory.class,
    ignoreResourceNotFound = true
)
public class CaseInsensitiveFileConfig {
}

@Configuration  
@PropertySource(
    value = "classpath:config/DATABASE.PROPERTIES",  // Will find database.properties
    factory = EnhancedCaseInsensitivePropertySourceFactory.class,
    ignoreResourceNotFound = true
)
public class DatabaseConfig {
}

// 4. Multiple file configuration
@Configuration
@PropertySource(
    value = {
        "classpath:APP.PROPERTIES",           // Will find app.properties
        "classpath:config/SERVER.PROPERTIES", // Will find server.properties
        "file:${user.home}/MYAPP.PROPERTIES"  // Will find myapp.properties
    },
    factory = EnhancedCaseInsensitivePropertySourceFactory.class,
    ignoreResourceNotFound = true
)
public class MultiFileConfig {
}

// 5. Programmatic registration example
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.support.EncodedResource;

import javax.annotation.PostConstruct;

@Configuration
public class ProgrammaticPropertySourceConfig {
    
    private final ConfigurableEnvironment environment;
    
    public ProgrammaticPropertySourceConfig(ConfigurableEnvironment environment) {
        this.environment = environment;
    }
    
    @PostConstruct
    public void addPropertySources() {
        try {
            EnhancedCaseInsensitivePropertySourceFactory factory = 
                new EnhancedCaseInsensitivePropertySourceFactory();
            
            // Try to load SETTINGS.PROPERTIES (will find settings.properties)
            ClassPathResource resource = new ClassPathResource("SETTINGS.PROPERTIES");
            EncodedResource encodedResource = new EncodedResource(resource);
            
            PropertySource<?> propertySource = factory.createPropertySource("settings", encodedResource);
            environment.getPropertySources().addLast(propertySource);
            
        } catch (Exception e) {
            System.err.println("Could not load case-insensitive property source: " + e.getMessage());
        }
    }
}

// 6. Usage example component
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class PropertyUsageExample {
    
    @Value("${app.name:Default App}")
    private String appName;
    
    @Value("${database.url:jdbc:h2:mem:testdb}")
    private String databaseUrl;
    
    @Value("${server.port:8080}")
    private int serverPort;
    
    public void printProperties() {
        System.out.println("=== Properties loaded from case-insensitive files ===");
        System.out.println("App Name: " + appName);
        System.out.println("Database URL: " + databaseUrl);
        System.out.println("Server Port: " + serverPort);
    }
}

// 7. Test runner
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class CaseInsensitiveFileTestRunner implements CommandLineRunner {
    
    private final PropertyUsageExample propertyExample;
    
    public CaseInsensitiveFileTestRunner(PropertyUsageExample propertyExample) {
        this.propertyExample = propertyExample;
    }
    
    @Override
    public void run(String... args) {
        System.out.println("=== Case-Insensitive Filename Property Loading Demo ===");
        propertyExample.printProperties();
    }
}

\\

# application.properties (lowercase - actual file)
# This file will be found even when referenced as APPLICATION.PROPERTIES
app.name=My Application
app.version=1.0.0
logging.level.root=INFO

# database.properties (lowercase - actual file)  
# This file will be found even when referenced as DATABASE.PROPERTIES
database.url=jdbc:mysql://localhost:3306/mydb
database.username=admin
database.password=secret
database.driver-class-name=com.mysql.cj.jdbc.Driver

# server.properties (lowercase - actual file)
# This file will be found even when referenced as SERVER.PROPERTIES
server.port=9090
server.servlet.context-path=/api
server.compression.enabled=true

# settings.properties (lowercase - actual file)
# This file will be found even when referenced as SETTINGS.PROPERTIES
feature.toggle.new-ui=true
feature.toggle.beta-features=false
cache.ttl=3600
cache.max-size=1000

# config/app.properties (in subdirectory)
# This file will be found even when referenced as config/APP.PROPERTIES
app.environment=development
app.debug=true
app.max-connections=100



======

// 1. Custom PropertySourceFactory with SpEL support
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.support.DefaultPropertySourceFactory;
import org.springframework.core.io.support.EncodedResource;
import org.springframework.core.io.support.PropertySourceFactory;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.DefaultResourceLoader;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class SpELPropertySourceFactory implements PropertySourceFactory {
    
    private final ExpressionParser parser = new SpelExpressionParser();
    private final ResourceLoader resourceLoader = new DefaultResourceLoader();
    private final DefaultPropertySourceFactory defaultFactory = new DefaultPropertySourceFactory();
    
    @Override
    public PropertySource<?> createPropertySource(String name, EncodedResource encodedResource) throws IOException {
        // Get the original URI
        String originalUri = encodedResource.getResource().getURI().toString();
        
        // Check if the URI contains SpEL expressions
        if (originalUri.contains("#{") && originalUri.contains("}")) {
            String evaluatedUri = evaluateSpELExpression(originalUri);
            
            // Create new resource with evaluated URI
            EncodedResource newEncodedResource = new EncodedResource(
                resourceLoader.getResource(evaluatedUri),
                encodedResource.getEncoding(),
                encodedResource.getCharset()
            );
            
            return defaultFactory.createPropertySource(name, newEncodedResource);
        }
        
        // No SpEL expressions, use original resource
        return defaultFactory.createPropertySource(name, encodedResource);
    }
    
    private String evaluateSpELExpression(String uri) {
        try {
            // Create evaluation context with helper methods
            StandardEvaluationContext context = new StandardEvaluationContext();
            context.setVariable("stringUtils", new StringUtils());
            context.setVariable("env", System.getenv());
            context.setVariable("props", System.getProperties());
            
            // Parse and evaluate the expression
            Expression expression = parser.parseExpression(uri, new SpELParserContext());
            return expression.getValue(context, String.class);
        } catch (Exception e) {
            throw new RuntimeException("Failed to evaluate SpEL expression in URI: " + uri, e);
        }
    }
    
    // Helper class for string manipulation in SpEL
    public static class StringUtils {
        public String toLowerCase(String str) {
            return str != null ? str.toLowerCase() : null;
        }
        
        public String toUpperCase(String str) {
            return str != null ? str.toUpperCase() : null;
        }
        
        public String replace(String str, String target, String replacement) {
            return str != null ? str.replace(target, replacement) : null;
        }
        
        public String substring(String str, int start, int end) {
            return str != null && str.length() >= end ? str.substring(start, end) : str;
        }
        
        public String concat(String... strings) {
            StringBuilder sb = new StringBuilder();
            for (String s : strings) {
                if (s != null) sb.append(s);
            }
            return sb.toString();
        }
    }
}

// 2. Custom SpEL Parser Context for template expressions
import org.springframework.expression.ParserContext;

public class SpELParserContext implements ParserContext {
    @Override
    public boolean isTemplate() {
        return true;
    }
    
    @Override
    public String getExpressionPrefix() {
        return "#{";
    }
    
    @Override
    public String getExpressionSuffix() {
        return "}";
    }
}

// 3. Configuration examples using SpEL for filename manipulation
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.beans.factory.annotation.Value;

@Configuration
// Convert filename to lowercase
@PropertySource(
    value = "classpath:#{#stringUtils.toLowerCase('APPLICATION')}.properties",
    factory = SpELPropertySourceFactory.class
)
public class LowerCaseFileConfig {
}

@Configuration
// Use environment variable for filename with case conversion
@PropertySource(
    value = "classpath:#{#stringUtils.toLowerCase(#env['CONFIG_FILE_NAME'] ?: 'DEFAULT')}.properties",
    factory = SpELPropertySourceFactory.class
)
public class EnvironmentBasedConfig {
}

@Configuration
// Complex filename manipulation
@PropertySource(
    value = "classpath:config/#{#stringUtils.toLowerCase(#stringUtils.replace('APP-CONFIG', '-', '_'))}.properties",
    factory = SpELPropertySourceFactory.class
)
public class ComplexFilenameConfig {
}

// 4. Enhanced version with more SpEL capabilities
import org.springframework.context.EnvironmentAware;
import org.springframework.core.env.Environment;

public class EnhancedSpELPropertySourceFactory implements PropertySourceFactory, EnvironmentAware {
    
    private final ExpressionParser parser = new SpelExpressionParser();
    private final ResourceLoader resourceLoader = new DefaultResourceLoader();
    private final DefaultPropertySourceFactory defaultFactory = new DefaultPropertySourceFactory();
    private Environment environment;
    
    @Override
    public void setEnvironment(Environment environment) {
        this.environment = environment;
    }
    
    @Override
    public PropertySource<?> createPropertySource(String name, EncodedResource encodedResource) throws IOException {
        String originalUri = encodedResource.getResource().getURI().toString();
        
        if (originalUri.contains("#{") && originalUri.contains("}")) {
            String evaluatedUri = evaluateSpELExpression(originalUri);
            
            EncodedResource newEncodedResource = new EncodedResource(
                resourceLoader.getResource(evaluatedUri),
                encodedResource.getEncoding(),
                encodedResource.getCharset()
            );
            
            return defaultFactory.createPropertySource(name, newEncodedResource);
        }
        
        return defaultFactory.createPropertySource(name, encodedResource);
    }
    
    private String evaluateSpELExpression(String uri) {
        try {
            StandardEvaluationContext context = new StandardEvaluationContext();
            
            // Add utility objects
            context.setVariable("stringUtils", new StringUtils());
            context.setVariable("fileUtils", new FileUtils());
            context.setVariable("env", System.getenv());
            context.setVariable("props", System.getProperties());  
            context.setVariable("spring", new SpringUtils(environment));
            
            Expression expression = parser.parseExpression(uri, new SpELParserContext());
            return expression.getValue(context, String.class);
        } catch (Exception e) {
            throw new RuntimeException("Failed to evaluate SpEL expression in URI: " + uri, e);
        }
    }
    
    // Enhanced utility classes
    public static class FileUtils {
        public String getBaseName(String filename) {
            if (filename == null) return null;
            int dotIndex = filename.lastIndexOf('.');
            return dotIndex > 0 ? filename.substring(0, dotIndex) : filename;
        }
        
        public String getExtension(String filename) {
            if (filename == null) return null;
            int dotIndex = filename.lastIndexOf('.');
            return dotIndex > 0 ? filename.substring(dotIndex) : "";
        }
        
        public String changeExtension(String filename, String newExtension) {
            String baseName = getBaseName(filename);
            return baseName + (newExtension.startsWith(".") ? newExtension : "." + newExtension);
        }
    }
    
    public static class SpringUtils {
        private final Environment environment;
        
        public SpringUtils(Environment environment) {
            this.environment = environment;
        }
        
        public String getProperty(String key) {
            return environment != null ? environment.getProperty(key) : null;
        }
        
        public String getProperty(String key, String defaultValue) {
            return environment != null ? environment.getProperty(key, defaultValue) : defaultValue;
        }
        
        public String[] getActiveProfiles() {
            return environment != null ? environment.getActiveProfiles() : new String[0];
        }
    }
}

// 5. Advanced configuration examples
@Configuration
@PropertySource(
    value = {
        // Basic case conversion
        "classpath:#{#stringUtils.toLowerCase('APPLICATION')}.properties",
        
        // Environment-based with fallback
        "classpath:#{#spring.getProperty('config.filename', 'application').toLowerCase()}.properties",
        
        // Profile-based filename
        "classpath:application-#{#spring.activeProfiles.length > 0 ? #spring.activeProfiles[0].toLowerCase() : 'default'}.properties",
        
        // Complex manipulation
        "classpath:#{#stringUtils.concat('config/', #stringUtils.toLowerCase(#env['APP_NAME'] ?: 'myapp'), '.properties')}"
    },
    factory = EnhancedSpELPropertySourceFactory.class,
    ignoreResourceNotFound = true
)
public class AdvancedSpELConfig {
}

// 6. Conditional loading based on SpEL
@Configuration
public class ConditionalSpELConfig {
    
    // Load different files based on environment
    @PropertySource(
        value = "classpath:#{#stringUtils.toLowerCase(#env['SPRING_PROFILES_ACTIVE'] ?: 'dev')}-config.properties",
        factory = EnhancedSpELPropertySourceFactory.class,
        ignoreResourceNotFound = true
    )
    static class ProfileBasedConfig {}
    
    // Load file with timestamp
    @PropertySource(
        value = "classpath:backup/#{#stringUtils.toLowerCase('CONFIG')}-#{T(java.time.LocalDate).now().toString()}.properties",
        factory = EnhancedSpELPropertySourceFactory.class,
        ignoreResourceNotFound = true
    )
    static class TimestampedConfig {}
}

// 7. Usage example with demonstration
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class SpELFilenameDemo {
    
    @Value("${app.name:SpEL Demo App}")
    private String appName;
    
    @Value("${config.source:unknown}")
    private String configSource;
    
    @Value("${profile.name:default}")
    private String profileName;
    
    public void demonstrateSpELFilenames() {
        System.out.println("=== SpEL Filename Manipulation Demo ===");
        System.out.println("App Name: " + appName);
        System.out.println("Config Source: " + configSource);
        System.out.println("Profile Name: " + profileName);
        System.out.println();
        System.out.println("Examples of SpEL filename expressions:");
        System.out.println("1. #{#stringUtils.toLowerCase('APPLICATION')} → application");
        System.out.println("2. #{#env['CONFIG_NAME'] ?: 'default'} → uses env var or default");
        System.out.println("3. #{#spring.activeProfiles[0]} → uses active profile");
        System.out.println("4. #{#fileUtils.changeExtension('config.yml', 'properties')} → config.properties");
    }
}

// 8. Test runner
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class SpELTestRunner implements CommandLineRunner {
    
    private final SpELFilenameDemo demo;
    
    public SpELTestRunner(SpELFilenameDemo demo) {
        this.demo = demo;
    }
    
    @Override
    public void run(String... args) {
        demo.demonstrateSpELFilenames();
    }
}


==
# application.properties (loaded by #{#stringUtils.toLowerCase('APPLICATION')})
app.name=SpEL Demo Application
config.source=application.properties
app.version=1.0.0

# default.properties (loaded when no environment variable is set)
app.name=Default Application
config.source=default.properties
profile.name=default

# dev-config.properties (loaded by profile-based SpEL)
app.name=Development Application  
config.source=dev-config.properties
profile.name=dev
database.url=jdbc:h2:mem:devdb

# prod-config.properties (loaded by profile-based SpEL)
app.name=Production Application
config.source=prod-config.properties  
profile.name=prod
database.url=jdbc:mysql://prod-server:3306/proddb

# config/myapp.properties (loaded by complex concat SpEL)
app.name=MyApp Configuration
config.source=config/myapp.properties
app.environment=development

# application-dev.properties (loaded by profile-based SpEL)
app.name=Dev Profile Application
config.source=application-dev.properties
debug.enabled=true

# application-prod.properties (loaded by profile-based SpEL)  
app.name=Prod Profile Application
config.source=application-prod.properties
debug.enabled=false

# Environment variable examples (set these as system properties or env vars):
# CONFIG_FILE_NAME=custom
# APP_NAME=myapp
# SPRING_PROFILES_ACTIVE=dev
