System.out.println("   Key: Exceptions are for exceptional conditions, not normal control flow");
        System.out.println();
    }
    
    // ===== ITEM 5: Prefer dependency injection to hardwiring resources =====
    
    // Bad: hardwired dependency
    static class BadSpellChecker {
        private static final Lexicon dictionary = new EnglishLexicon(); // Hardwired!
        
        private BadSpellChecker() {} // Noninstantiable
        
        public static boolean isValid(String word) {
            return dictionary.contains(word);
        }
        
        public static List<String> suggestions(String typo) {
            return dictionary.getSuggestions(typo);
        }
    }
    
    // Good: dependency injection
    static class GoodSpellChecker {
        private final Lexicon dictionary;
        
        public GoodSpellChecker(Lexicon dictionary) {
            this.dictionary = Objects.requireNonNull(dictionary);
        }
        
        public boolean isValid(String word) {
            return dictionary.contains(word);
        }
        
        public List<String> suggestions(String typo) {
            return dictionary.getSuggestions(typo);
        }
    }
    
    interface Lexicon {
        boolean contains(String word);
        List<String> getSuggestions(String typo);
    }
    
    static class EnglishLexicon implements Lexicon {
        private final Set<String> words = Set.of("hello", "world", "java", "effective", "programming");
        
        @Override
        public boolean contains(String word) {
            return words.contains(word.toLowerCase());
        }
        
        @Override
        public List<String> getSuggestions(String typo) {
            return words.stream()
                       .filter(word -> word.startsWith(typo.substring(0, Math.min(2, typo.length()))))
                       .collect(java.util.stream.Collectors.toList());
        }
    }
    
    static class SpanishLexicon implements Lexicon {
        private final Set<String> words = Set.of("hola", "mundo", "java", "efectivo", "programacion");
        
        @Override
        public boolean contains(String word) {
            return words.contains(word.toLowerCase());
        }
        
        @Override
        public List<String> getSuggestions(String typo) {
            return words.stream()
                       .filter(word -> word.startsWith(typo.substring(0, Math.min(2, typo.length()))))
                       .collect(java.util.stream.Collectors.toList());
        }
    }
    
    private static void demonstrateDependencyInjection() {
        System.out.println("40. Dependency Injection:");
        
        // Can use different dictionaries
        GoodSpellChecker englishChecker = new GoodSpellChecker(new EnglishLexicon());
        GoodSpellChecker spanishChecker = new GoodSpellChecker(new SpanishLexicon());
        
        System.out.println("   English - 'hello' valid: " + englishChecker.isValid("hello"));
        System.out.println("   Spanish - 'hola' valid: " + spanishChecker.isValid("hola"));
        System.out.println("   English suggestions for 'he': " + englishChecker.suggestions("he"));
        System.out.println("   Spanish suggestions for 'ho': " + spanishChecker.suggestions("ho"));
        System.out.println("   Dependency injection allows flexibility and testability");
        System.out.println();
    }
    
    // ===== ITEM 7: Eliminate obsolete object references =====
    
    static class Stack {
        private Object[] elements;
        private int size = 0;
        private static final int DEFAULT_INITIAL_CAPACITY = 16;
        
        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }
        
        public void push(Object e) {
            ensureCapacity();
            elements[size++] = e;
        }
        
        // Memory leak version
        public Object popBad() {
            if (size == 0) {
                throw new IllegalStateException("Stack is empty");
            }
            return elements[--size]; // Memory leak! Still holds reference
        }
        
        // Fixed version
        public Object pop() {
            if (size == 0) {
                throw new IllegalStateException("Stack is empty");
            }
            Object result = elements[--size];
            elements[size] = null; // Eliminate obsolete reference
            return result;
        }
        
        private void ensureCapacity() {
            if (elements.length == size) {
                elements = Arrays.copyOf(elements, 2 * size + 1);
            }
        }
        
        public int size() {
            return size;
        }
        
        public boolean isEmpty() {
            return size == 0;
        }
    }
    
    // Demonstrate listener memory leak
    static class EventSource {
        private final List<EventListener> listeners = new ArrayList<>();
        
        public void addListener(EventListener listener) {
            listeners.add(listener);
        }
        
        // Good: provide removal method
        public void removeListener(EventListener listener) {
            listeners.remove(listener);
        }
        
        public void fireEvent(String event) {
            for (EventListener listener : listeners) {
                listener.onEvent(event);
            }
        }
        
        // Use WeakHashMap for automatic cleanup of unused listeners
        private final Map<EventListener, String> weakListeners = new WeakHashMap<>();
        
        public void addWeakListener(EventListener listener, String tag) {
            weakListeners.put(listener, tag);
        }
        
        public void fireWeakEvent(String event) {
            for (EventListener listener : weakListeners.keySet()) {
                listener.onEvent(event + " (weak)");
            }
        }
    }
    
    interface EventListener {
        void onEvent(String event);
    }
    
    private static void demonstrateMemoryLeaks() {
        System.out.println("41. Eliminating Memory Leaks:");
        
        Stack stack = new Stack();
        stack.push("item1");
        stack.push("item2");
        stack.push("item3");
        
        System.out.println("   Stack size after pushes: " + stack.size());
        
        // Pop items (using good version that nulls references)
        while (!stack.isEmpty()) {
            Object item = stack.pop();
            System.out.println("   Popped: " + item);
        }
        
        // Demonstrate listener pattern
        EventSource source = new EventSource();
        EventListener listener = event -> System.out.println("   Received: " + event);
        
        source.addListener(listener);
        source.fireEvent("test event");
        
        // Important: remove listener to prevent memory leak
        source.removeListener(listener);
        
        // Weak reference example
        source.addWeakListener(listener, "weak-tag");
        source.fireWeakEvent("weak event");
        
        System.out.println("   Key: Null out obsolete references, especially in collections");
        System.out.println();
    }
    
    // ===== ITEM 14: Consider implementing Comparable =====
    
    static class PhoneNumber implements Comparable<PhoneNumber> {
        private final short areaCode, prefix, lineNum;
        
        public PhoneNumber(int areaCode, int prefix, int lineNum) {
            this.areaCode = rangeCheck(areaCode, 999, "area code");
            this.prefix = rangeCheck(prefix, 999, "prefix");
            this.lineNum = rangeCheck(lineNum, 9999, "line num");
        }
        
        private static short rangeCheck(int val, int max, String arg) {
            if (val < 0 || val > max) {
                throw new IllegalArgumentException(arg + ": " + val);
            }
            return (short) val;
        }
        
        @Override
        public boolean equals(Object o) {
            if (o == this) return true;
            if (!(o instanceof PhoneNumber)) return false;
            PhoneNumber pn = (PhoneNumber) o;
            return pn.lineNum == lineNum && pn.prefix == prefix && pn.areaCode == areaCode;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(areaCode, prefix, lineNum);
        }
        
        // Comparable implementation using comparator construction methods
        private static final Comparator<PhoneNumber> COMPARATOR =
            Comparator.comparingInt((PhoneNumber pn) -> pn.areaCode)
                     .thenComparingInt(pn -> pn.prefix)
                     .thenComparingInt(pn -> pn.lineNum);
        
        @Override
        public int compareTo(PhoneNumber pn) {
            return COMPARATOR.compare(this, pn);
        }
        
        @Override
        public String toString() {
            return String.format("(%03d) %03d-%04d", areaCode, prefix, lineNum);
        }
    }
    
    private static void demonstrateComparable() {
        System.out.println("42. Implementing Comparable:");
        
        List<PhoneNumber> phoneNumbers = Arrays.asList(
            new PhoneNumber(707, 867, 5309),
            new PhoneNumber(555, 867, 5309),
            new PhoneNumber(707, 867, 5308),
            new PhoneNumber(555, 123, 4567)
        );
        
        System.out.println("   Original order:");
        phoneNumbers.forEach(pn -> System.out.println("     " + pn));
        
        Collections.sort(phoneNumbers);
        System.out.println("   Sorted order:");
        phoneNumbers.forEach(pn -> System.out.println("     " + pn));
        
        // Binary search works with Comparable
        PhoneNumber key = new PhoneNumber(555, 867, 5309);
        int index = Collections.binarySearch(phoneNumbers, key);
        System.out.println("   Found " + key + " at index: " + index);
        System.out.println();
    }
    
    // ===== ITEM 23: Prefer class hierarchies to tagged classes =====
    
    // Bad: tagged class
    static class BadFigure {
        enum Shape { RECTANGLE, CIRCLE }
        
        // Tag field - the shape of this figure
        final Shape shape;
        
        // These fields are used only if shape is RECTANGLE
        double length;
        double width;
        
        // This field is used only if shape is CIRCLE
        double radius;
        
        // Constructor for circle
        BadFigure(double radius) {
            shape = Shape.CIRCLE;
            this.radius = radius;
        }
        
        // Constructor for rectangle
        BadFigure(double length, double width) {
            shape = Shape.RECTANGLE;
            this.length = length;
            this.width = width;
        }
        
        double area() {
            switch (shape) {
                case RECTANGLE:
                    return length * width;
                case CIRCLE:
                    return Math.PI * (radius * radius);
                default:
                    throw new AssertionError(shape);
            }
        }
    }
    
    // Good: class hierarchy
    static abstract class Figure {
        abstract double area();
    }
    
    static class Circle extends Figure {
        final double radius;
        
        Circle(double radius) {
            this.radius = radius;
        }
        
        @Override
        double area() {
            return Math.PI * radius * radius;
        }
        
        @Override
        public String toString() {
            return String.format("Circle(radius=%.1f)", radius);
        }
    }
    
    static class Rectangle extends Figure {
        final double length;
        final double width;
        
        Rectangle(double length, double width) {
            this.length = length;
            this.width = width;
        }
        
        @Override
        double area() {
            return length * width;
        }
        
        @Override
        public String toString() {
            return String.format("Rectangle(%.1fx%.1f)", length, width);
        }
    }
    
    // Easy to extend
    static class Square extends Rectangle {
        Square(double side) {
            super(side, side);
        }
        
        @Override
        public String toString() {
            return String.format("Square(%.1f)", length);
        }
    }
    
    private static void demonstrateClassHierarchies() {
        System.out.println("43. Class Hierarchies vs Tagged Classes:");
        
        List<Figure> figures = Arrays.asList(
            new Circle(5.0),
            new Rectangle(3.0, 4.0),
            new Square(2.0)
        );
        
        for (Figure figure : figures) {
            System.out.println("   " + figure + " area: " + String.format("%.2f", figure.area()));
        }
        
        System.out.println("   Class hierarchies are more flexible and type-safe than tagged classes");
        System.out.println();
    }
    
    // ===== ITEM 24: Favor static member classes over nonstatic =====
    
    static class OuterClass {
        private final String name;
        
        public OuterClass(String name) {
            this.name = name;
        }
        
        // Good: static member class (no implicit reference to outer instance)
        static class StaticNested {
            private final String data;
            
            public StaticNested(String data) {
                this.data = data;
            }
            
            public String getData() {
                return data;
                // Cannot access outer instance fields directly
            }
        }
        
        // Non-static member class (has implicit reference to outer instance)
        class NonStaticNested {
            private final String info;
            
            public NonStaticNested(String info) {
                this.info = info;
            }
            
            public String getInfo() {
                return info + " from " + name; // Can access outer instance
            }
        }
        
        // Good use of non-static: when you need access to outer instance
        public Iterator<String> iterator() {
            return new IteratorImpl();
        }
        
        private class IteratorImpl implements Iterator<String> {
            private int position = 0;
            private final String[] items = {name + "-item1", name + "-item2", name + "-item3"};
            
            @Override
            public boolean hasNext() {
                return position < items.length;
            }
            
            @Override
            public String next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return items[position++];
            }
        }
        
        public String getName() {
            return name;
        }
    }
    
    private static void demonstrateNestedClasses() {
        System.out.println("44. Static vs Non-static Nested Classes:");
        
        // Static nested class - no outer instance needed
        OuterClass.StaticNested staticNested = new OuterClass.StaticNested("static-data");
        System.out.println("   Static nested: " + staticNested.getData());
        
        // Non-static nested class - needs outer instance
        OuterClass outer = new OuterClass("MyOuter");
        OuterClass.NonStaticNested nonStatic = outer.new NonStaticNested("non-static-info");
        System.out.println("   Non-static nested: " + nonStatic.getInfo());
        
        // Good use of non-static: iterator that accesses outer state
        System.out.println("   Iterator from outer class:");
        Iterator<String> iterator = outer.iterator();
        while (iterator.hasNext()) {
            System.out.println("     " + iterator.next());
        }
        
        System.out.println("   Use static nested classes unless you need outer instance access");
        System.out.println();
    }
    
    // ===== ITEM 27: Eliminate unchecked warnings =====
    
    @SuppressWarnings("unchecked")
    static class SafeArrayList<E> {
        private Object[] elements;
        private int size = 0;
        
        public SafeArrayList() {
            elements = new Object[10];
        }
        
        public void add(E element) {
            if (size == elements.length) {
                elements = Arrays.copyOf(elements, size * 2);
            }
            elements[size++] = element;
        }
        
        @SuppressWarnings("unchecked")
        public E get(int index) {
            if (index >= size) {
                throw new IndexOutOfBoundsException();
            }
            return (E) elements[index]; // Safe cast - we control what goes in
        }
        
        public int size() {
            return size;
        }
        
        // Safe generic array creation
        @SafeVarargs
        public static <T> List<T> listOf(T... elements) {
            List<T> list = new ArrayList<>();
            Collections.addAll(list, elements);
            return list;
        }
    }
    
    private static void demonstrateUncheckedWarnings() {
        System.out.println("45. Eliminating Unchecked Warnings:");
        
        // Properly parameterized collections
        List<String> strings = new ArrayList<>(); // Diamond operator
        strings.add("hello");
        strings.add("world");
        
        // Safe varargs method
        List<Integer> numbers = SafeArrayList.listOf(1, 2, 3, 4, 5);
        System.out.println("   Created list: " + numbers);
        
        // Custom safe array list
        SafeArrayList<String> safeList = new SafeArrayList<>();
        safeList.add("safe");
        safeList.add("generic");
        safeList.add("list");
        
        System.out.println("   Safe list contents:");
        for (int i = 0; i < safeList.size(); i++) {
            System.out.println("     " + safeList.get(i));
        }
        
        System.out.println("   Use @SuppressWarnings(\"unchecked\") only when you're sure it's safe");
        System.out.println();
    }
    
    // ===== ITEM 34: Use enums instead of int constants =====
    
    // Bad: int enum pattern
    static class BadConstants {
        public static final int APPLE_FUJI = 0;
        public static final int APPLE_PIPPIN = 1;
        public static final int APPLE_GRANNY_SMITH = 2;
        
        public static final int ORANGE_NAVEL = 0;
        public static final int ORANGE_TEMPLE = 1;
        public static final int ORANGE_BLOOD = 2;
    }
    
    // Good: enum types
    enum Apple {
        FUJI(5.0), PIPPIN(3.0), GRANNY_SMITH(4.0);
        
        private final double price;
        
        Apple(double price) {
            this.price = price;
        }
        
        public double getPrice() {
            return price;
        }
        
        @Override
        public String toString() {
            return name().toLowerCase().replace('_', ' ');
        }
    }
    
    enum Orange {
        NAVEL(4.0), TEMPLE(3.5), BLOOD(6.0);
        
        private final double price;
        
        Orange(double price) {
            this.price = price;
        }
        
        public double getPrice() {
            return price;
        }
        
        @Override
        public String toString() {
            return name().toLowerCase().replace('_', ' ');
        }
    }
    
    // Rich enum with behavior
    enum Planet {
        MERCURY(3.303e+23, 2.4397e6),
        VENUS(4.869e+24, 6.0518e6),
        EARTH(5.976e+24, 6.37814e6),
        MARS(6.421e+23, 3.3972e6);
        
        private final double mass;           // In kilograms
        private final double radius;         // In meters
        private final double surfaceGravity; // In m / s^2
        
        // Universal gravitational constant in m^3 / kg s^2
        private static final double G = 6.67300E-11;
        
        Planet(double mass, double radius) {
            this.mass = mass;
            this.radius = radius;
            surfaceGravity = G * mass / (radius * radius);
        }
        
        public double mass() { return mass; }
        public double radius() { return radius; }
        public double surfaceGravity() { return surfaceGravity; }
        
        public double surfaceWeight(double mass) {
            return mass * surfaceGravity; // F = ma
        }
    }
    
    private static void demonstrateEnumUsage() {
        System.out.println("46. Enums vs Int Constants:");
        
        // Type safety with enums
        Apple apple = Apple.FUJI;
        Orange orange = Orange.NAVEL;
        
        System.out.println("   Apple: " + apple + " ($" + apple.getPrice() + ")");
        System.out.println("   Orange: " + orange + " ($" + orange.getPrice() + ")");
        
        // Cannot compare different enum types (compile-time safety)
        // if (apple == orange) // Compilation error!
        
        // Rich enum example
        double earthWeight = 175.0; // pounds
        System.out.println("   Weight on different planets for " + earthWeight + " lbs:");
        for (Planet p : Planet.values()) {
            double weight = p.surfaceWeight(earthWeight / Planet.EARTH.surfaceGravity());
            System.out.println("     " + p + ": " + String.format("%.1f", weight) + " lbs");
        }
        System.out.println();
    }
    
    // ===== ITEM 36: Use EnumSet instead of bit fields =====
    
    // Bad: bit field enumeration constants
    static class BadText {
        public static final int STYLE_BOLD = 1 << 0;         // 1
        public static final int STYLE_ITALIC = 1 << 1;       // 2
        public static final int STYLE_UNDERLINE = 1 << 2;    // 4
        public static final int STYLE_STRIKETHROUGH = 1 << 3; // 8
        
        // Parameter is a bitwise OR of zero or more STYLE_ constants
        public void applyStyles(int styles) {
            System.out.println("   Applied styles (bit field): " + styles);
            if ((styles & STYLE_BOLD) != 0) System.out.println("     Bold");
            if ((styles & STYLE_ITALIC) != 0) System.out.println("     Italic");
            if ((styles & STYLE_UNDERLINE) != 0) System.out.println("     Underline");
            if ((styles & STYLE_STRIKETHROUGH) != 0) System.out.println("     Strikethrough");
        }
    }
    
    // Good: EnumSet instead of bit fields
    static class GoodText {
        enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }
        
        // Parameter is an EnumSet instead of bit field
        public void applyStyles(Set<Style> styles) {
            System.out.println("   Applied styles (EnumSet): " + styles);
            for (Style style : styles) {
                System.out.println("     " + style.name().toLowerCase());
            }
        }
    }
    
    private static void demonstrateEnumSet() {
        System.out.println("47. EnumSet vs Bit Fields:");
        
        // Bad approach with bit fields
        BadText badText = new BadText();
        badText.applyStyles(BadText.STYLE_BOLD | BadText.STYLE_ITALIC);
        
        // Good approach with EnumSet
        GoodText goodText = new GoodText();
        goodText.applyStyles(EnumSet.of(GoodText.Style.BOLD, GoodText.Style.ITALIC));
        
        // EnumSet operations
        Set<GoodText.Style> allStyles = EnumSet.allOf(GoodText.Style.class);
        Set<GoodText.Style> noStyles = EnumSet.noneOf(GoodText.Style.class);
        Set<GoodText.Style> boldAndItalic = EnumSet.of(GoodText.Style.BOLD, GoodText.Style.ITALIC);
        
        System.out.println("   All styles: " + allStyles);
        System.out.println("   No styles: " + noStyles);
        System.out.println("   Bold and italic: " + boldAndItalic);
        
        // EnumSet is internally implemented as bit vector for performance
        System.out.println("   EnumSet provides bit field performance with enum type safety");
        System.out.println();
    }
    
    // ===== ITEM 37: Use EnumMap instead of ordinal indexing =====
    
    enum Phase {
        SOLID, LIQUID, GAS;
        
        enum Transition {
            MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),
            BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),
            SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);
            
            private final Phase from;
            private final Phase to;
            
            Transition(Phase from, Phase to) {
                this.from = from;
                this.to = to;
            }
            
            // Initialize the phase transition map
            private static final Map<Phase, Map<Phase, Transition>> m =
                Stream.of(values()).collect(
                    java.util.stream.Collectors.groupingBy(
                        t -> t.from,
                        () -> new EnumMap<>(Phase.class),
                        java.util.stream.Collectors.toMap(
                            t -> t.to,
                            t -> t,
                            (x, y) -> y,
                            () -> new EnumMap<>(Phase.class))));
            
            public static Transition from(Phase from, Phase to) {
                return m.get(from).get(to);
            }
        }
    }
    
    static class Plant {
        enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL }
        
        final String name;
        final LifeCycle lifeCycle;
        
        Plant(String name, LifeCycle lifeCycle) {
            this.name = name;
            this.lifeCycle = lifeCycle;
        }
        
        @Override
        public String toString() {
            return name;
        }
    }
    
    private static void demonstrateEnumMap() {
        System.out.println("48. EnumMap vs Ordinal Indexing:");
        
        // Phase transitions
        System.out.println("   Phase transitions:");
        System.out.println("     SOLID to LIQUID: " + Phase.Transition.from(Phase.SOLID, Phase.LIQUID));
        System.out.println("     LIQUID to GAS: " + Phase.Transition.from(Phase.LIQUID, Phase.GAS));
        System.out.println("     GAS to SOLID: " + Phase.Transition.from(Phase.GAS, Phase.SOLID));
        
        // Plant lifecycle grouping using EnumMap
        List<Plant> garden = Arrays.asList(
            new Plant("Rose", Plant.LifeCycle.PERENNIAL),
            new Plant("Sunflower", Plant.LifeCycle.ANNUAL),
            new Plant("Carrot", Plant.LifeCycle.BIENNIAL),
            new Plant("Oak", Plant.LifeCycle.PERENNIAL),
            new Plant("Marigold", Plant.LifeCycle.ANNUAL)
        );
        
        // Good: Using EnumMap
        Map<Plant.LifeCycle, Set<Plant>> plantsByLifeCycle = new EnumMap<>(Plant.LifeCycle.class);
        for (Plant.LifeCycle lc : Plant.LifeCycle.values()) {
            plantsByLifeCycle.put(lc, new HashSet<>());
        }
        for (Plant p : garden) {
            plantsByLifeCycle.get(p.lifeCycle).add(p);
        }
        
        System.out.println("   Plants grouped by lifecycle:");
        for (Map.Entry<Plant.LifeCycle, Set<Plant>> entry : plantsByLifeCycle.entrySet()) {
            System.out.println("     " + entry.getKey() + ": " + entry.getValue());
        }
        
        // Even better: Using streams with EnumMap
        Map<Plant.LifeCycle, List<Plant>> plantsByLifeCycleStream = garden.stream()
            .collect(java.util.stream.Collectors.groupingBy(
                p -> p.lifeCycle,
                () -> new EnumMap<>(Plant.LifeCycle.class),
                java.util.stream.Collectors.toList()));
        
        System.out.println("   Using streams: " + plantsByLifeCycleStream);
        System.out.println();
    }
    
    // ===== ITEM 38: Emulate extensible enums with interfaces =====
    
    interface Operation {
        double apply(double x, double y);
    }
    
    enum BasicOperation implements Operation {
        PLUS("+") {
            public double apply(double x, double y) { return x + y; }
        },
        MINUS("-") {
            public double apply(double x, double y) { return x - y; }
        },
        TIMES("*") {
            public double apply(double x, double y) { return x * y; }
        },
        DIVIDE("/") {
            public double apply(double x, double y) { return x / y; }
        };
        
        private final String symbol;
        
        BasicOperation(String symbol) {
            this.symbol = symbol;
        }
        
        @Override
        public String toString() {
            return symbol;
        }
    }
    
    // Extended operations - new enum implementing same interface
    enum ExtendedOperation implements Operation {
        EXP("^") {
            public double apply(double x, double y) { return Math.pow(x, y); }
        },
        REMAINDER("%") {
            public double apply(double x, double y) { return x % y; }
        };
        
        private final String symbol;
        
        ExtendedOperation(String symbol) {
            this.symbol = symbol;
        }
        
        @Override
        public String toString() {
            return symbol;
        }
    }
    
    // Test method that works with any Operation implementation
    private static void test(Class<? extends Enum<? extends Operation>> opEnumType,
                           double x, double y) {
        for (Operation op : opEnumType.getEnumConstants()) {
            System.out.printf("   %.1f %s %.1f = %.1f%n", x, op, y, op.apply(x, y));
        }
    }
    
    // Alternative test method using Collection
    private static void test(Collection<? extends Operation> opSet, double x, double y) {
        for (Operation op : opSet) {
            System.out.printf("   %.1f %s %.1f = %.1f%n", x, op, y, op.apply(x, y));
        }
    }
    
    private static void demonstrateExtensibleEnums() {
        System.out.println("49. Extensible Enums with Interfaces:");
        
        double x = 4.0;
        double y = 2.0;
        
        System.out.println("   Basic operations:");
        test(BasicOperation.class, x, y);
        
        System.out.println("   Extended operations:");
        test(ExtendedOperation.class, x, y);
        
        System.out.println("   Mixed operations using Collection:");
        Collection<Operation> operations = Arrays.asList(
            BasicOperation.PLUS,
            BasicOperation.TIMES,
            ExtendedOperation.EXP,
            ExtendedOperation.REMAINDER
        );
        test(operations, x, y);
        
        System.out.println("   Interfaces allow enum extension while maintaining type safety");
        System.out.println();
    }import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.time.LocalDateTime;

/**
 * Comprehensive examples demonstrating key principles from "Effective Java" by Joshua Bloch
 */
public class EffectiveJavaExamples {
    
    public static void main(String[] args) {
        System.out.println("=== Effective Java Examples ===\n");
        
        // Item 1: Static factory methods
        demonstrateStaticFactoryMethods();
        
        // Item 2: Builder pattern
        demonstrateBuilderPattern();
        
        // Item 3: Singleton enforcement
        demonstrateSingleton();
        
        // Item 8: Avoid finalizers and cleaners
        demonstrateCleanupPatterns();
        
        // Item 10: Override equals
        demonstrateEqualsContract();
        
        // Item 17: Minimize mutability
        demonstrateImmutability();
        
        // Item 26: Don't use raw types
        demonstrateGenerics();
        
        // Item 49: Check parameters for validity
        demonstrateParameterValidation();
        
        // Item 57: Minimize the scope of local variables
        demonstrateVariableScope();
        
        // Item 15: Minimize the accessibility of classes and members
        demonstrateEncapsulation();
        
        // Item 18: Favor composition over inheritance
        demonstrateComposition();
        
        // Item 20: Prefer interfaces to abstract classes
        demonstrateInterfaces();
        
        // Item 50: Make defensive copies when needed
        demonstrateDefensiveCopying();
        
        // Item 61: Prefer primitive types to boxed primitives
        demonstratePrimitiveTypes();
        
        // Item 62: Avoid strings where other types are more appropriate
        demonstrateStringUsage();
        
        // Item 64: Refer to objects by their interfaces
        demonstrateInterfaceReferences();
        
        // Item 78: Synchronize access to shared mutable data
        demonstrateSynchronization();
        
        // Item 81: Prefer concurrency utilities to wait and notify
        demonstrateConcurrencyUtilities();
        
        // Item 90: Consider serialization proxies instead of serialized instances
        demonstrateSerializationProxy();
        
        // Item 11: Always override hashCode when you override equals
        demonstrateHashCodeContract();
        
        // Item 13: Override clone judiciously
        demonstrateCloning();
        
        // Item 25: Limit source files to a single top-level class
        demonstrateSingleTopLevelClass();
        
        // Item 30: Favor generic methods
        demonstrateGenericMethods();
        
        // Item 33: Consider typesafe heterogeneous containers
        demonstrateTypesafeContainers();
        
        // Item 47: Prefer Collection to Stream as a return type
        demonstrateCollectionVsStream();
        
        // Item 52: Use overloading judiciously
        demonstrateOverloading();
        
        // Item 65: Prefer interfaces to reflection
        demonstrateReflectionAlternatives();
        
        // Item 67: Optimize judiciously
        demonstrateOptimization();
        
        // Item 85: Prefer alternatives to Java serialization
        demonstrateSerializationAlternatives();
        
        // Item 4: Enforce noninstantiability with a private constructor
        demonstrateNoninstantiability();
        
        // Item 6: Avoid creating unnecessary objects
        demonstrateObjectReuse();
        
        // Item 9: Prefer try-with-resources to try-finally
        demonstrateTryWithResources();
        
        // Item 16: In public classes, use accessor methods, not public fields
        demonstrateAccessorMethods();
        
        // Item 19: Design and document for inheritance or else prohibit it
        demonstrateInheritanceDesign();
        
        // Item 22: Use interfaces only to define types
        demonstrateInterfaceUsage();
        
        // Item 43: Prefer method references to lambdas
        demonstrateMethodReferences();
        
        // Item 45: Use streams judiciously
        demonstrateStreamUsage();
        
        // Item 58: Prefer for-each loops to traditional for loops
        demonstrateForEachLoops();
        
        // Item 69: Use exceptions only for exceptional conditions
        demonstrateExceptionUsage();
        
        // Item 5: Prefer dependency injection to hardwiring resources
        demonstrateDependencyInjection();
        
        // Item 7: Eliminate obsolete object references
        demonstrateMemoryLeaks();
        
        // Item 14: Consider implementing Comparable
        demonstrateComparable();
        
        // Item 23: Prefer class hierarchies to tagged classes
        demonstrateClassHierarchies();
        
        // Item 24: Favor static member classes over nonstatic
        demonstrateNestedClasses();
        
        // Item 27: Eliminate unchecked warnings
        demonstrateUncheckedWarnings();
        
        // Item 34: Use enums instead of int constants
        demonstrateEnumUsage();
        
        // Item 36: Use EnumSet instead of bit fields
        demonstrateEnumSet();
        
        // Item 37: Use EnumMap instead of ordinal indexing
        demonstrateEnumMap();
        
        // Item 38: Emulate extensible enums with interfaces
        demonstrateExtensibleEnums();
    }
    
    // ===== ITEM 1: Consider static factory methods instead of constructors =====
    
    static class Currency {
        private final String code;
        private final String name;
        
        // Private constructor - forces use of factory methods
        private Currency(String code, String name) {
            this.code = code;
            this.name = name;
        }
        
        // Static factory methods with descriptive names
        public static Currency ofCode(String code) {
            return new Currency(code, getNameForCode(code));
        }
        
        public static Currency usd() {
            return new Currency("USD", "US Dollar");
        }
        
        public static Currency eur() {
            return new Currency("EUR", "Euro");
        }
        
        private static String getNameForCode(String code) {
            Map<String, String> codeToName = Map.of(
                "USD", "US Dollar",
                "EUR", "Euro",
                "GBP", "British Pound"
            );
            return codeToName.getOrDefault(code, "Unknown");
        }
        
        @Override
        public String toString() {
            return String.format("%s (%s)", name, code);
        }
    }
    
    private static void demonstrateStaticFactoryMethods() {
        System.out.println("1. Static Factory Methods:");
        System.out.println("   " + Currency.usd());
        System.out.println("   " + Currency.ofCode("GBP"));
        System.out.println();
    }
    
    // ===== ITEM 2: Consider a builder when faced with many constructor parameters =====
    
    static class DatabaseConnection {
        private final String host;
        private final int port;
        private final String database;
        private final String username;
        private final String password;
        private final boolean ssl;
        private final int timeout;
        private final int maxConnections;
        
        private DatabaseConnection(Builder builder) {
            this.host = builder.host;
            this.port = builder.port;
            this.database = builder.database;
            this.username = builder.username;
            this.password = builder.password;
            this.ssl = builder.ssl;
            this.timeout = builder.timeout;
            this.maxConnections = builder.maxConnections;
        }
        
        public static class Builder {
            // Required parameters
            private final String host;
            private final String database;
            
            // Optional parameters with defaults
            private int port = 5432;
            private String username = "user";
            private String password = "";
            private boolean ssl = false;
            private int timeout = 30;
            private int maxConnections = 10;
            
            public Builder(String host, String database) {
                this.host = Objects.requireNonNull(host);
                this.database = Objects.requireNonNull(database);
            }
            
            public Builder port(int port) {
                if (port <= 0 || port > 65535) {
                    throw new IllegalArgumentException("Port must be between 1 and 65535");
                }
                this.port = port;
                return this;
            }
            
            public Builder credentials(String username, String password) {
                this.username = Objects.requireNonNull(username);
                this.password = Objects.requireNonNull(password);
                return this;
            }
            
            public Builder ssl(boolean ssl) {
                this.ssl = ssl;
                return this;
            }
            
            public Builder timeout(int timeout) {
                if (timeout <= 0) {
                    throw new IllegalArgumentException("Timeout must be positive");
                }
                this.timeout = timeout;
                return this;
            }
            
            public Builder maxConnections(int maxConnections) {
                if (maxConnections <= 0) {
                    throw new IllegalArgumentException("Max connections must be positive");
                }
                this.maxConnections = maxConnections;
                return this;
            }
            
            public DatabaseConnection build() {
                return new DatabaseConnection(this);
            }
        }
        
        @Override
        public String toString() {
            return String.format("DatabaseConnection{host='%s', port=%d, database='%s', " +
                    "username='%s', ssl=%s, timeout=%d, maxConnections=%d}",
                    host, port, database, username, ssl, timeout, maxConnections);
        }
    }
    
    private static void demonstrateBuilderPattern() {
        System.out.println("2. Builder Pattern:");
        DatabaseConnection conn = new DatabaseConnection.Builder("localhost", "mydb")
                .port(3306)
                .credentials("admin", "secret")
                .ssl(true)
                .timeout(60)
                .maxConnections(20)
                .build();
        System.out.println("   " + conn);
        System.out.println();
    }
    
    // ===== ITEM 3: Enforce the singleton property with a private constructor or an enum type =====
    
    enum ConfigManager {
        INSTANCE;
        
        private final Map<String, String> properties = new ConcurrentHashMap<>();
        
        public void setProperty(String key, String value) {
            properties.put(key, value);
        }
        
        public String getProperty(String key) {
            return properties.get(key);
        }
        
        public void loadDefaults() {
            properties.put("app.name", "Effective Java Demo");
            properties.put("app.version", "1.0.0");
            properties.put("debug", "false");
        }
    }
    
    private static void demonstrateSingleton() {
        System.out.println("3. Singleton Pattern (Enum):");
        ConfigManager config = ConfigManager.INSTANCE;
        config.loadDefaults();
        config.setProperty("user.session", "active");
        
        System.out.println("   App: " + config.getProperty("app.name"));
        System.out.println("   Version: " + config.getProperty("app.version"));
        System.out.println("   Session: " + config.getProperty("user.session"));
        System.out.println();
    }
    
    // ===== ITEM 8: Avoid finalizers and cleaners =====
    
    static class ManagedResource implements AutoCloseable {
        private boolean closed = false;
        private final String resourceName;
        
        public ManagedResource(String resourceName) {
            this.resourceName = resourceName;
            System.out.println("   Resource '" + resourceName + "' acquired");
        }
        
        public void doWork() {
            if (closed) {
                throw new IllegalStateException("Resource is closed");
            }
            System.out.println("   Working with resource '" + resourceName + "'");
        }
        
        @Override
        public void close() {
            if (!closed) {
                System.out.println("   Resource '" + resourceName + "' released");
                closed = true;
            }
        }
    }
    
    private static void demonstrateCleanupPatterns() {
        System.out.println("4. Proper Resource Management (try-with-resources):");
        try (ManagedResource resource = new ManagedResource("database-connection")) {
            resource.doWork();
            // Resource automatically closed at end of try block
        }
        System.out.println();
    }
    
    // ===== ITEM 10: Obey the general contract when overriding equals =====
    
    static class Person {
        private final String name;
        private final int age;
        private final String email;
        
        public Person(String name, int age, String email) {
            this.name = Objects.requireNonNull(name);
            this.age = age;
            this.email = Objects.requireNonNull(email);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;  // Reflexive
            if (obj == null || getClass() != obj.getClass()) return false;  // Null check and type check
            
            Person person = (Person) obj;
            return age == person.age &&
                   Objects.equals(name, person.name) &&
                   Objects.equals(email, person.email);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, age, email);
        }
        
        @Override
        public String toString() {
            return String.format("Person{name='%s', age=%d, email='%s'}", name, age, email);
        }
    }
    
    private static void demonstrateEqualsContract() {
        System.out.println("5. Proper equals() and hashCode() Implementation:");
        Person p1 = new Person("Alice", 30, "alice@example.com");
        Person p2 = new Person("Alice", 30, "alice@example.com");
        Person p3 = new Person("Bob", 25, "bob@example.com");
        
        System.out.println("   p1.equals(p2): " + p1.equals(p2));  // true
        System.out.println("   p1.equals(p3): " + p1.equals(p3));  // false
        System.out.println("   p1.hashCode() == p2.hashCode(): " + (p1.hashCode() == p2.hashCode()));  // true
        
        Set<Person> people = new HashSet<>();
        people.add(p1);
        people.add(p2);  // Won't be added (duplicate)
        people.add(p3);
        System.out.println("   Set size: " + people.size());  // 2
        System.out.println();
    }
    
    // ===== ITEM 17: Minimize mutability =====
    
    static final class ImmutablePoint {
        private final double x;
        private final double y;
        
        public ImmutablePoint(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        public double getX() { return x; }
        public double getY() { return y; }
        
        // Returns new instance instead of modifying existing
        public ImmutablePoint translate(double dx, double dy) {
            return new ImmutablePoint(x + dx, y + dy);
        }
        
        public double distanceFrom(ImmutablePoint other) {
            double dx = this.x - other.x;
            double dy = this.y - other.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            ImmutablePoint point = (ImmutablePoint) obj;
            return Double.compare(point.x, x) == 0 && Double.compare(point.y, y) == 0;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
        
        @Override
        public String toString() {
            return String.format("Point(%.1f, %.1f)", x, y);
        }
    }
    
    private static void demonstrateImmutability() {
        System.out.println("6. Immutable Classes:");
        ImmutablePoint origin = new ImmutablePoint(0, 0);
        ImmutablePoint moved = origin.translate(3, 4);
        
        System.out.println("   Original: " + origin);
        System.out.println("   After translation: " + moved);
        System.out.println("   Distance: " + String.format("%.1f", origin.distanceFrom(moved)));
        System.out.println();
    }
    
    // ===== ITEM 26: Don't use raw types =====
    
    private static void demonstrateGenerics() {
        System.out.println("7. Proper Use of Generics:");
        
        // Good: Using parameterized types
        List<String> strings = new ArrayList<>();
        strings.add("Hello");
        strings.add("World");
        
        Map<String, Integer> wordCounts = new HashMap<>();
        for (String word : strings) {
            wordCounts.put(word, word.length());
        }
        
        System.out.println("   Word counts: " + wordCounts);
        
        // Demonstrate type safety
        processStrings(strings);
        System.out.println();
    }
    
    private static void processStrings(List<String> strings) {
        System.out.println("   Processing " + strings.size() + " strings safely");
        strings.forEach(s -> System.out.println("     Length of '" + s + "': " + s.length()));
    }
    
    // ===== ITEM 49: Check parameters for validity =====
    
    static class BankAccount {
        private double balance;
        private final String accountNumber;
        
        public BankAccount(String accountNumber, double initialBalance) {
            this.accountNumber = Objects.requireNonNull(accountNumber, "Account number cannot be null");
            if (accountNumber.trim().isEmpty()) {
                throw new IllegalArgumentException("Account number cannot be empty");
            }
            if (initialBalance < 0) {
                throw new IllegalArgumentException("Initial balance cannot be negative");
            }
            this.balance = initialBalance;
        }
        
        public void withdraw(double amount) {
            Objects.requireNonNull(amount, "Amount cannot be null");
            if (amount <= 0) {
                throw new IllegalArgumentException("Withdrawal amount must be positive");
            }
            if (amount > balance) {
                throw new IllegalArgumentException("Insufficient funds");
            }
            balance -= amount;
        }
        
        public void deposit(double amount) {
            if (amount <= 0) {
                throw new IllegalArgumentException("Deposit amount must be positive");
            }
            balance += amount;
        }
        
        public double getBalance() {
            return balance;
        }
        
        @Override
        public String toString() {
            return String.format("Account %s: $%.2f", accountNumber, balance);
        }
    }
    
    private static void demonstrateParameterValidation() {
        System.out.println("8. Parameter Validation:");
        try {
            BankAccount account = new BankAccount("ACC-001", 1000.0);
            System.out.println("   " + account);
            
            account.deposit(250.0);
            System.out.println("   After deposit: " + account);
            
            account.withdraw(100.0);
            System.out.println("   After withdrawal: " + account);
            
            // This will throw an exception
            account.withdraw(-50.0);
        } catch (IllegalArgumentException e) {
            System.out.println("   Caught expected exception: " + e.getMessage());
        }
        System.out.println();
    }
    
    // ===== ITEM 57: Minimize the scope of local variables =====
    
    private static void demonstrateVariableScope() {
        System.out.println("9. Minimizing Variable Scope:");
        
        List<String> items = Arrays.asList("apple", "banana", "cherry", "date");
        
        // Good: declare loop variable in the for statement
        System.out.println("   Items with their lengths:");
        for (int i = 0; i < items.size(); i++) {
            String item = items.get(i);  // Declare as close to use as possible
            int length = item.length();   // Declare when needed
            System.out.println("     " + item + ": " + length + " characters");
        }
        
        // Even better: use enhanced for loop when possible
        System.out.println("   Uppercase items:");
        for (String item : items) {  // item scope limited to this loop
            String uppercase = item.toUpperCase();  // Declare close to use
            System.out.println("     " + uppercase);
        }
        
        // Demonstrate early initialization
        Map<String, Integer> itemLengths = processItems(items);
        System.out.println("   Processed items: " + itemLengths.size());
        System.out.println();
    }
    
    private static Map<String, Integer> processItems(List<String> items) {
        // Initialize collections when declared
        Map<String, Integer> result = new HashMap<>();
        
        for (String item : items) {
            // Minimize scope by declaring variables close to their use
            int length = item.length();
            result.put(item, length);
        }
        
        return result;
    }
    
    // ===== ITEM 15: Minimize the accessibility of classes and members =====
    
    static class UserAccount {
        // Private fields - no direct access from outside
        private final String username;
        private String email;
        private final List<String> permissions;
        private boolean active;
        
        // Package-private constructor for controlled instantiation
        UserAccount(String username, String email) {
            this.username = Objects.requireNonNull(username);
            this.email = Objects.requireNonNull(email);
            this.permissions = new ArrayList<>();
            this.active = true;
        }
        
        // Public accessor methods with appropriate visibility
        public String getUsername() {
            return username;
        }
        
        public String getEmail() {
            return email;
        }
        
        // Defensive copy for mutable field
        public List<String> getPermissions() {
            return new ArrayList<>(permissions);
        }
        
        public boolean isActive() {
            return active;
        }
        
        // Package-private mutator for controlled modification
        void setEmail(String email) {
            this.email = Objects.requireNonNull(email);
        }
        
        void addPermission(String permission) {
            if (!permissions.contains(permission)) {
                permissions.add(permission);
            }
        }
        
        void deactivate() {
            this.active = false;
        }
        
        // Private helper method
        private boolean hasPermission(String permission) {
            return permissions.contains(permission);
        }
        
        @Override
        public String toString() {
            return String.format("UserAccount{username='%s', email='%s', permissions=%d, active=%s}",
                    username, email, permissions.size(), active);
        }
    }
    
    private static void demonstrateEncapsulation() {
        System.out.println("10. Proper Encapsulation:");
        UserAccount user = new UserAccount("alice", "alice@example.com");
        user.addPermission("READ");
        user.addPermission("WRITE");
        
        System.out.println("   " + user);
        System.out.println("   Permissions: " + user.getPermissions());
        
        // Cannot directly modify internal state
        List<String> perms = user.getPermissions();
        perms.add("DELETE"); // This won't affect the original
        System.out.println("   After attempted external modification: " + user.getPermissions().size());
        System.out.println();
    }
    
    // ===== ITEM 18: Favor composition over inheritance =====
    
    // Bad example: using inheritance inappropriately
    static class BadStack<E> extends ArrayList<E> {
        public void push(E item) {
            add(item);
        }
        
        public E pop() {
            return remove(size() - 1);
        }
        
        // Problem: inherits all ArrayList methods, breaking stack abstraction
    }
    
    // Good example: using composition
    static class GoodStack<E> {
        private final List<E> elements = new ArrayList<>();
        
        public void push(E item) {
            elements.add(item);
        }
        
        public E pop() {
            if (elements.isEmpty()) {
                throw new IllegalStateException("Stack is empty");
            }
            return elements.remove(elements.size() - 1);
        }
        
        public E peek() {
            if (elements.isEmpty()) {
                throw new IllegalStateException("Stack is empty");
            }
            return elements.get(elements.size() - 1);
        }
        
        public boolean isEmpty() {
            return elements.isEmpty();
        }
        
        public int size() {
            return elements.size();
        }
        
        @Override
        public String toString() {
            return "Stack" + elements.toString();
        }
    }
    
    private static void demonstrateComposition() {
        System.out.println("11. Composition over Inheritance:");
        GoodStack<String> stack = new GoodStack<>();
        stack.push("first");
        stack.push("second");
        stack.push("third");
        
        System.out.println("   Stack: " + stack);
        System.out.println("   Peek: " + stack.peek());
        System.out.println("   Pop: " + stack.pop());
        System.out.println("   After pop: " + stack);
        System.out.println();
    }
    
    // ===== ITEM 20: Prefer interfaces to abstract classes =====
    
    interface Shape {
        double area();
        double perimeter();
        
        // Default method (Java 8+)
        default String describe() {
            return String.format("Shape with area %.2f and perimeter %.2f", area(), perimeter());
        }
    }
    
    interface Drawable {
        void draw();
        
        default void highlight() {
            System.out.println("   Highlighting shape...");
        }
    }
    
    // Can implement multiple interfaces
    static class Circle implements Shape, Drawable {
        private final double radius;
        
        public Circle(double radius) {
            if (radius <= 0) {
                throw new IllegalArgumentException("Radius must be positive");
            }
            this.radius = radius;
        }
        
        @Override
        public double area() {
            return Math.PI * radius * radius;
        }
        
        @Override
        public double perimeter() {
            return 2 * Math.PI * radius;
        }
        
        @Override
        public void draw() {
            System.out.println("   Drawing circle with radius " + radius);
        }
        
        @Override
        public String toString() {
            return String.format("Circle(radius=%.1f)", radius);
        }
    }
    
    static class Rectangle implements Shape, Drawable {
        private final double width;
        private final double height;
        
        public Rectangle(double width, double height) {
            if (width <= 0 || height <= 0) {
                throw new IllegalArgumentException("Dimensions must be positive");
            }
            this.width = width;
            this.height = height;
        }
        
        @Override
        public double area() {
            return width * height;
        }
        
        @Override
        public double perimeter() {
            return 2 * (width + height);
        }
        
        @Override
        public void draw() {
            System.out.println("   Drawing rectangle " + width + "x" + height);
        }
        
        @Override
        public String toString() {
            return String.format("Rectangle(%.1fx%.1f)", width, height);
        }
    }
    
    private static void demonstrateInterfaces() {
        System.out.println("12. Interfaces over Abstract Classes:");
        List<Shape> shapes = Arrays.asList(
            new Circle(5.0),
            new Rectangle(4.0, 6.0)
        );
        
        for (Shape shape : shapes) {
            if (shape instanceof Drawable) {
                ((Drawable) shape).draw();
            }
            System.out.println("   " + shape.describe());
        }
        System.out.println();
    }
    
    // ===== ITEM 50: Make defensive copies when needed =====
    
    static class DateRange {
        private final Date start;
        private final Date end;
        
        public DateRange(Date start, Date end) {
            // Defensive copying of mutable parameters
            this.start = new Date(start.getTime());
            this.end = new Date(end.getTime());
            
            if (this.start.after(this.end)) {
                throw new IllegalArgumentException("Start date must be before end date");
            }
        }
        
        // Defensive copying in accessors
        public Date getStart() {
            return new Date(start.getTime());
        }
        
        public Date getEnd() {
            return new Date(end.getTime());
        }
        
        public boolean contains(Date date) {
            return !date.before(start) && !date.after(end);
        }
        
        @Override
        public String toString() {
            return String.format("DateRange{%s to %s}", start, end);
        }
    }
    
    private static void demonstrateDefensiveCopying() {
        System.out.println("13. Defensive Copying:");
        Date start = new Date();
        Date end = new Date(start.getTime() + 86400000); // +1 day
        
        DateRange range = new DateRange(start, end);
        System.out.println("   Original range: " + range);
        
        // Attempt to modify original dates
        start.setTime(0); // This won't affect the DateRange
        
        System.out.println("   After modifying original start: " + range);
        
        // Getting defensive copies
        Date retrievedStart = range.getStart();
        retrievedStart.setTime(0); // This won't affect the DateRange either
        
        System.out.println("   After modifying retrieved start: " + range);
        System.out.println();
    }
    
    // ===== ITEM 61: Prefer primitive types to boxed primitives =====
    
    private static void demonstratePrimitiveTypes() {
        System.out.println("14. Primitive Types vs Boxed Primitives:");
        
        // Performance comparison
        long startTime = System.nanoTime();
        long sum = 0L; // primitive
        for (int i = 0; i < 1000000; i++) {
            sum += i;
        }
        long primitiveTime = System.nanoTime() - startTime;
        
        startTime = System.nanoTime();
        Long boxedSum = 0L; // boxed primitive
        for (int i = 0; i < 1000000; i++) {
            boxedSum += i; // auto-boxing/unboxing overhead
        }
        long boxedTime = System.nanoTime() - startTime;
        
        System.out.println("   Primitive sum: " + sum + " (time: " + primitiveTime / 1000000.0 + "ms)");
        System.out.println("   Boxed sum: " + boxedSum + " (time: " + boxedTime / 1000000.0 + "ms)");
        
        // Identity vs equality issues
        Integer a = 127;
        Integer b = 127;
        Integer c = 128;
        Integer d = 128;
        
        System.out.println("   Integer.valueOf(127) == Integer.valueOf(127): " + (a == b)); // true (cached)
        System.out.println("   Integer.valueOf(128) == Integer.valueOf(128): " + (c == d)); // false (not cached)
        System.out.println("   Always use .equals() for boxed primitives: " + c.equals(d)); // true
        System.out.println();
    }
    
    // ===== ITEM 62: Avoid strings where other types are more appropriate =====
    
    enum LogLevel {
        DEBUG, INFO, WARN, ERROR;
        
        public boolean isAtLeast(LogLevel other) {
            return this.ordinal() >= other.ordinal();
        }
    }
    
    static class ThreadSafeCounter {
        private static final Object lock = new Object();
        private static int count = 0;
        
        public static int increment() {
            synchronized (lock) {
                return ++count;
            }
        }
    }
    
    static class Logger {
        private final LogLevel threshold;
        
        public Logger(LogLevel threshold) {
            this.threshold = threshold;
        }
        
        public void log(LogLevel level, String message) {
            if (level.isAtLeast(threshold)) {
                System.out.println(String.format("[%s] %s", level, message));
            }
        }
    }
    
    private static void demonstrateStringUsage() {
        System.out.println("15. Avoiding Strings for Non-String Data:");
        
        // Good: Using enum instead of string constants
        Logger logger = new Logger(LogLevel.INFO);
        logger.log(LogLevel.DEBUG, "Debug message"); // Won't print
        logger.log(LogLevel.INFO, "Info message");   // Will print
        logger.log(LogLevel.ERROR, "Error message"); // Will print
        
        // Good: Using proper synchronization instead of string-based locks
        System.out.println("   Counter value: " + ThreadSafeCounter.increment());
        System.out.println("   Counter value: " + ThreadSafeCounter.increment());
        
        // Demonstrate compound key using proper class instead of string concatenation
        Map<PersonKey, String> personData = new HashMap<>();
        PersonKey key = new PersonKey("John", "Doe", 30);
        personData.put(key, "Software Engineer");
        
        System.out.println("   Person data: " + personData.get(key));
        System.out.println();
    }
    
    static class PersonKey {
        private final String firstName;
        private final String lastName;
        private final int age;
        
        public PersonKey(String firstName, String lastName, int age) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            PersonKey personKey = (PersonKey) obj;
            return age == personKey.age &&
                   Objects.equals(firstName, personKey.firstName) &&
                   Objects.equals(lastName, personKey.lastName);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(firstName, lastName, age);
        }
    }
    
    // ===== ITEM 64: Refer to objects by their interfaces =====
    
    private static void demonstrateInterfaceReferences() {
        System.out.println("16. Referring to Objects by Interfaces:");
        
        // Good: using interface types
        List<String> arrayList = new ArrayList<>();
        List<String> linkedList = new LinkedList<>();
        Set<String> hashSet = new HashSet<>();
        Set<String> treeSet = new TreeSet<>();
        Map<String, Integer> hashMap = new HashMap<>();
        Map<String, Integer> treeMap = new TreeMap<>();
        
        // Can easily switch implementations
        processCollection(arrayList, "ArrayList");
        processCollection(linkedList, "LinkedList");
        processCollection(hashSet, "HashSet");
        processCollection(treeSet, "TreeSet");
        
        processMap(hashMap, "HashMap");
        processMap(treeMap, "TreeMap");
        System.out.println();
    }
    
    private static void processCollection(Collection<String> collection, String type) {
        collection.add("item1");
        collection.add("item2");
        System.out.println("   " + type + " size: " + collection.size());
    }
    
    private static void processMap(Map<String, Integer> map, String type) {
        map.put("key1", 1);
        map.put("key2", 2);
        System.out.println("   " + type + " size: " + map.size());
    }
    
    // ===== ITEM 78: Synchronize access to shared mutable data =====
    
    static class SafeCounter {
        private int count = 0;
        
        public synchronized int increment() {
            return ++count;
        }
        
        public synchronized int get() {
            return count;
        }
    }
    
    static class AtomicCounter {
        private final java.util.concurrent.atomic.AtomicInteger count = 
            new java.util.concurrent.atomic.AtomicInteger(0);
        
        public int increment() {
            return count.incrementAndGet();
        }
        
        public int get() {
            return count.get();
        }
    }
    
    private static void demonstrateSynchronization() {
        System.out.println("17. Thread-Safe Access to Shared Data:");
        
        SafeCounter safeCounter = new SafeCounter();
        AtomicCounter atomicCounter = new AtomicCounter();
        
        // Simulate concurrent access
        List<Thread> threads = new ArrayList<>();
        
        for (int i = 0; i < 5; i++) {
            Thread t = new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    safeCounter.increment();
                    atomicCounter.increment();
                }
            });
            threads.add(t);
            t.start();
        }
        
        // Wait for all threads to complete
        for (Thread t : threads) {
            try {
                t.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        System.out.println("   Safe counter final value: " + safeCounter.get());
        System.out.println("   Atomic counter final value: " + atomicCounter.get());
        System.out.println();
    }
    
    // ===== ITEM 81: Prefer concurrency utilities to wait and notify =====
    
    static class ProducerConsumerExample {
        private final java.util.concurrent.BlockingQueue<String> queue = 
            new java.util.concurrent.ArrayBlockingQueue<>(10);
        private final java.util.concurrent.CountDownLatch latch = 
            new java.util.concurrent.CountDownLatch(1);
        
        public void produce() {
            try {
                for (int i = 1; i <= 5; i++) {
                    String item = "Item " + i;
                    queue.put(item);
                    System.out.println("   Produced: " + item);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown();
            }
        }
        
        public void consume() {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    String item = queue.poll(200, java.util.concurrent.TimeUnit.MILLISECONDS);
                    if (item != null) {
                        System.out.println("   Consumed: " + item);
                    } else if (latch.getCount() == 0 && queue.isEmpty()) {
                        break; // Producer finished and queue is empty
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    private static void demonstrateConcurrencyUtilities() {
        System.out.println("18. Using Concurrency Utilities:");
        
        ProducerConsumerExample example = new ProducerConsumerExample();
        
        Thread producer = new Thread(example::produce);
        Thread consumer = new Thread(example::consume);
        
        producer.start();
        consumer.start();
        
        try {
            producer.join();
            consumer.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Demonstrate thread-safe collections
        Map<String, String> concurrentMap = new ConcurrentHashMap<>();
        concurrentMap.put("key1", "value1");
        concurrentMap.put("key2", "value2");
        System.out.println("   Concurrent map: " + concurrentMap);
        System.out.println();
    }
    
    // ===== ITEM 90: Consider serialization proxies instead of serialized instances =====
    
    static class Period implements java.io.Serializable {
        private static final long serialVersionUID = 1L;
        private final Date start;
        private final Date end;
        
        public Period(Date start, Date end) {
            this.start = new Date(start.getTime());
            this.end = new Date(end.getTime());
            
            if (this.start.after(this.end)) {
                throw new IllegalArgumentException("Start after end: " + this.start + " > " + this.end);
            }
        }
        
        public Date start() {
            return new Date(start.getTime());
        }
        
        public Date end() {
            return new Date(end.getTime());
        }
        
        @Override
        public String toString() {
            return String.format("Period{%s - %s}", start, end);
        }
        
        // Serialization proxy pattern
        private static class SerializationProxy implements java.io.Serializable {
            private static final long serialVersionUID = 1L;
            private final Date start;
            private final Date end;
            
            SerializationProxy(Period period) {
                this.start = period.start;
                this.end = period.end;
            }
            
            private Object readResolve() {
                return new Period(start, end); // Uses public constructor with validation
            }
        }
        
        private Object writeReplace() {
            return new SerializationProxy(this);
        }
        
        private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
            throw new java.io.InvalidObjectException("Proxy required");
        }
    }
    
    private static void demonstrateSerializationProxy() {
        System.out.println("19. Serialization Proxy Pattern:");
        
        try {
            Date start = new Date();
            Date end = new Date(start.getTime() + 86400000); // +1 day
            Period original = new Period(start, end);
            
            // Serialize
            java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
            java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(baos);
            oos.writeObject(original);
            oos.close();
            
            // Deserialize
            java.io.ByteArrayInputStream bais = new java.io.ByteArrayInputStream(baos.toByteArray());
            java.io.ObjectInputStream ois = new java.io.ObjectInputStream(bais);
            Period deserialized = (Period) ois.readObject();
            ois.close();
            
            System.out.println("   Original: " + original);
            System.out.println("   Deserialized: " + deserialized);
            System.out.println("   Objects equal: " + original.toString().equals(deserialized.toString()));
            
        } catch (Exception e) {
            System.out.println("   Serialization demo failed: " + e.getMessage());
        }
        System.out.println();
    }
    
    // ===== ITEM 11: Always override hashCode when you override equals =====
    
    static class BadPoint {
        private final int x, y;
        
        public BadPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            BadPoint badPoint = (BadPoint) obj;
            return x == badPoint.x && y == badPoint.y;
        }
        
        // Missing hashCode override - violates contract!
    }
    
    static class GoodPoint {
        private final int x, y;
        
        public GoodPoint(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            GoodPoint goodPoint = (GoodPoint) obj;
            return x == goodPoint.x && y == goodPoint.y;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
        
        @Override
        public String toString() {
            return String.format("Point(%d, %d)", x, y);
        }
    }
    
    private static void demonstrateHashCodeContract() {
        System.out.println("20. hashCode Contract:");
        
        // Demonstrate the problem with missing hashCode
        BadPoint bp1 = new BadPoint(1, 2);
        BadPoint bp2 = new BadPoint(1, 2);
        
        System.out.println("   BadPoint equals: " + bp1.equals(bp2)); // true
        System.out.println("   BadPoint same hashCode: " + (bp1.hashCode() == bp2.hashCode())); // may be false!
        
        Set<BadPoint> badSet = new HashSet<>();
        badSet.add(bp1);
        System.out.println("   BadPoint found in set: " + badSet.contains(bp2)); // may be false!
        
        // Demonstrate correct behavior
        GoodPoint gp1 = new GoodPoint(1, 2);
        GoodPoint gp2 = new GoodPoint(1, 2);
        
        System.out.println("   GoodPoint equals: " + gp1.equals(gp2)); // true
        System.out.println("   GoodPoint same hashCode: " + (gp1.hashCode() == gp2.hashCode())); // true
        
        Set<GoodPoint> goodSet = new HashSet<>();
        goodSet.add(gp1);
        System.out.println("   GoodPoint found in set: " + goodSet.contains(gp2)); // true
        System.out.println();
    }
    
    // ===== ITEM 13: Override clone judiciously =====
    
    static class CloneableStack implements Cloneable {
        private Object[] elements;
        private int size = 0;
        private static final int DEFAULT_CAPACITY = 16;
        
        public CloneableStack() {
            this.elements = new Object[DEFAULT_CAPACITY];
        }
        
        public void push(Object e) {
            ensureCapacity();
            elements[size++] = e;
        }
        
        public Object pop() {
            if (size == 0) {
                throw new IllegalStateException("Stack is empty");
            }
            Object result = elements[--size];
            elements[size] = null; // Eliminate obsolete reference
            return result;
        }
        
        private void ensureCapacity() {
            if (elements.length == size) {
                elements = Arrays.copyOf(elements, 2 * size + 1);
            }
        }
        
        // Proper clone implementation for arrays
        @Override
        public CloneableStack clone() {
            try {
                CloneableStack result = (CloneableStack) super.clone();
                result.elements = elements.clone(); // Deep copy the array
                return result;
            } catch (CloneNotSupportedException e) {
                throw new AssertionError(); // Can't happen
            }
        }
        
        public int size() {
            return size;
        }
        
        @Override
        public String toString() {
            return "Stack with " + size + " elements";
        }
    }
    
    // Alternative: Copy constructor (often better than clone)
    static class CopyConstructorStack {
        private Object[] elements;
        private int size = 0;
        
        public CopyConstructorStack() {
            this.elements = new Object[16];
        }
        
        // Copy constructor
        public CopyConstructorStack(CopyConstructorStack original) {
            this.elements = original.elements.clone();
            this.size = original.size;
        }
        
        public void push(Object e) {
            if (elements.length == size) {
                elements = Arrays.copyOf(elements, 2 * size + 1);
            }
            elements[size++] = e;
        }
        
        public int size() {
            return size;
        }
        
        @Override
        public String toString() {
            return "CopyStack with " + size + " elements";
        }
    }
    
    private static void demonstrateCloning() {
        System.out.println("21. Cloning vs Copy Constructor:");
        
        CloneableStack original = new CloneableStack();
        original.push("first");
        original.push("second");
        
        CloneableStack cloned = original.clone();
        cloned.push("third");
        
        System.out.println("   Original: " + original);
        System.out.println("   Cloned: " + cloned);
        
        // Copy constructor approach (preferred)
        CopyConstructorStack originalCopy = new CopyConstructorStack();
        originalCopy.push("first");
        originalCopy.push("second");
        
        CopyConstructorStack copied = new CopyConstructorStack(originalCopy);
        copied.push("third");
        
        System.out.println("   Original copy: " + originalCopy);
        System.out.println("   Copied: " + copied);
        System.out.println();
    }
    
    // ===== ITEM 25: Limit source files to a single top-level class =====
    
    // Good: Single top-level class per file
    static class UtilityContainer {
        // Nested classes are fine
        static class Parser {
            public String parse(String input) {
                return "Parsed: " + input;
            }
        }
        
        static class Validator {
            public boolean validate(String input) {
                return input != null && !input.trim().isEmpty();
            }
        }
        
        static class Formatter {
            public String format(String input) {
                return input.toUpperCase().trim();
            }
        }
    }
    
    private static void demonstrateSingleTopLevelClass() {
        System.out.println("22. Single Top-Level Class Design:");
        
        UtilityContainer.Parser parser = new UtilityContainer.Parser();
        UtilityContainer.Validator validator = new UtilityContainer.Validator();
        UtilityContainer.Formatter formatter = new UtilityContainer.Formatter();
        
        String input = " hello world ";
        
        if (validator.validate(input)) {
            String parsed = parser.parse(input);
            String formatted = formatter.format(parsed);
            System.out.println("   Result: " + formatted);
        }
        System.out.println();
    }
    
    // ===== ITEM 30: Favor generic methods =====
    
    static class GenericUtilities {
        // Generic method with type parameter
        public static <T> Set<T> union(Set<T> s1, Set<T> s2) {
            Set<T> result = new HashSet<>(s1);
            result.addAll(s2);
            return result;
        }
        
        // Generic method with bounded type parameter
        public static <T extends Comparable<T>> T max(Collection<T> collection) {
            if (collection.isEmpty()) {
                throw new IllegalArgumentException("Empty collection");
            }
            
            T result = null;
            for (T element : collection) {
                if (result == null || element.compareTo(result) > 0) {
                    result = element;
                }
            }
            return result;
        }
        
        // Generic method with wildcard
        public static void printCollection(Collection<?> collection) {
            for (Object element : collection) {
                System.out.println("     " + element);
            }
        }
        
        // Recursive type bound
        public static <T extends Comparable<T>> List<T> sort(List<T> list) {
            List<T> result = new ArrayList<>(list);
            Collections.sort(result);
            return result;
        }
    }
    
    private static void demonstrateGenericMethods() {
        System.out.println("23. Generic Methods:");
        
        Set<String> set1 = Set.of("apple", "banana");
        Set<String> set2 = Set.of("cherry", "date");
        Set<String> union = GenericUtilities.union(set1, set2);
        
        System.out.println("   Union of sets: " + union);
        
        List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9);
        Integer max = GenericUtilities.max(numbers);
        System.out.println("   Max number: " + max);
        
        List<String> words = Arrays.asList("zebra", "apple", "mango");
        List<String> sorted = GenericUtilities.sort(words);
        System.out.println("   Sorted words: " + sorted);
        
        System.out.println("   Collection contents:");
        GenericUtilities.printCollection(union);
        System.out.println();
    }
    
    // ===== ITEM 33: Consider typesafe heterogeneous containers =====
    
    static class Favorites {
        private final Map<Class<?>, Object> favorites = new HashMap<>();
        
        public <T> void putFavorite(Class<T> type, T instance) {
            favorites.put(Objects.requireNonNull(type), type.cast(instance));
        }
        
        public <T> T getFavorite(Class<T> type) {
            return type.cast(favorites.get(type));
        }
        
        public Set<Class<?>> getTypes() {
            return new HashSet<>(favorites.keySet());
        }
    }
    
    private static void demonstrateTypesafeContainers() {
        System.out.println("24. Typesafe Heterogeneous Containers:");
        
        Favorites favorites = new Favorites();
        
        // Type-safe storage of different types
        favorites.putFavorite(String.class, "Java");
        favorites.putFavorite(Integer.class, 42);
        favorites.putFavorite(Class.class, Favorites.class);
        
        // Type-safe retrieval
        String favoriteString = favorites.getFavorite(String.class);
        Integer favoriteInteger = favorites.getFavorite(Integer.class);
        Class<?> favoriteClass = favorites.getFavorite(Class.class);
        
        System.out.println("   Favorite String: " + favoriteString);
        System.out.println("   Favorite Integer: " + favoriteInteger);
        System.out.println("   Favorite Class: " + favoriteClass.getSimpleName());
        System.out.println("   Stored types: " + favorites.getTypes().stream()
                .map(Class::getSimpleName)
                .collect(java.util.stream.Collectors.joining(", ")));
        System.out.println();
    }
    
    // ===== ITEM 47: Prefer Collection to Stream as a return type =====
    
    static class PowerSetExample {
        // Returns Collection for flexibility
        public static <E> Collection<Set<E>> powerSet(Set<E> set) {
            List<E> src = new ArrayList<>(set);
            if (src.size() > 30) {
                throw new IllegalArgumentException("Set too big: " + src.size());
            }
            
            return new AbstractList<Set<E>>() {
                @Override
                public int size() {
                    return 1 << src.size(); // 2^size
                }
                
                @Override
                public boolean contains(Object o) {
                    return o instanceof Set && src.containsAll((Set<?>) o);
                }
                
                @Override
                public Set<E> get(int index) {
                    Set<E> result = new HashSet<>();
                    for (int i = 0; index != 0; i++, index >>= 1) {
                        if ((index & 1) == 1) {
                            result.add(src.get(i));
                        }
                    }
                    return result;
                }
            };
        }
    }
    
    private static void demonstrateCollectionVsStream() {
        System.out.println("25. Collection Return Types:");
        
        Set<String> input = Set.of("a", "b", "c");
        Collection<Set<String>> powerSet = PowerSetExample.powerSet(input);
        
        System.out.println("   Power set size: " + powerSet.size());
        System.out.println("   Power set contents:");
        powerSet.stream().limit(8).forEach(subset -> 
            System.out.println("     " + subset));
        
        // Can use as Collection
        System.out.println("   Contains {a, b}: " + powerSet.contains(Set.of("a", "b")));
        
        // Can stream when needed
        long singletonCount = powerSet.stream()
                .filter(set -> set.size() == 1)
                .count();
        System.out.println("   Singleton sets: " + singletonCount);
        System.out.println();
    }
    
    // ===== ITEM 52: Use overloading judiciously =====
    
    static class CollectionClassifier {
        // Problematic overloading - resolved at compile time
        public static String classify(Set<?> set) {
            return "Set";
        }
        
        public static String classify(List<?> list) {
            return "List";
        }
        
        public static String classify(Collection<?> collection) {
            return "Unknown Collection";
        }
        
        // Better approach - single method with runtime type checking
        public static String classifyCorrectly(Collection<?> collection) {
            return collection instanceof Set ? "Set" :
                   collection instanceof List ? "List" : "Unknown Collection";
        }
    }
    
    // Constructor overloading done right
    static class Timer {
        private final long duration;
        private final java.util.concurrent.TimeUnit unit;
        
        public Timer(long duration) {
            this(duration, java.util.concurrent.TimeUnit.MILLISECONDS);
        }
        
        public Timer(long duration, java.util.concurrent.TimeUnit unit) {
            this.duration = duration;
            this.unit = Objects.requireNonNull(unit);
        }
        
        public long getDurationInMillis() {
            return unit.toMillis(duration);
        }
        
        @Override
        public String toString() {
            return duration + " " + unit.toString().toLowerCase();
        }
    }
    
    private static void demonstrateOverloading() {
        System.out.println("26. Judicious Overloading:");
        
        Collection<?>[] collections = {
            new HashSet<String>(),
            new ArrayList<String>(),
            new LinkedList<String>()
        };
        
        // Problematic overloading - all resolve to Collection version
        System.out.println("   Problematic overloading:");
        for (Collection<?> c : collections) {
            System.out.println("     " + CollectionClassifier.classify(c)); // Always "Unknown Collection"
        }
        
        // Correct approach
        System.out.println("   Correct classification:");
        for (Collection<?> c : collections) {
            System.out.println("     " + CollectionClassifier.classifyCorrectly(c));
        }
        
        // Good constructor overloading
        Timer timer1 = new Timer(1000);
        Timer timer2 = new Timer(5, java.util.concurrent.TimeUnit.SECONDS);
        
        System.out.println("   Timer1: " + timer1 + " (" + timer1.getDurationInMillis() + "ms)");
        System.out.println("   Timer2: " + timer2 + " (" + timer2.getDurationInMillis() + "ms)");
        System.out.println();
    }
    
    // ===== ITEM 65: Prefer interfaces to reflection =====
    
    interface Animal {
        void makeSound();
        String getName();
    }
    
    static class Dog implements Animal {
        private final String name;
        
        public Dog(String name) {
            this.name = name;
        }
        
        @Override
        public void makeSound() {
            System.out.println("     " + name + " says: Woof!");
        }
        
        @Override
        public String getName() {
            return name;
        }
    }
    
    static class Cat implements Animal {
        private final String name;
        
        public Cat(String name) {
            this.name = name;
        }
        
        @Override
        public void makeSound() {
            System.out.println("     " + name + " says: Meow!");
        }
        
        @Override
        public String getName() {
            return name;
        }
    }
    
    // Factory method instead of reflection
    static class AnimalFactory {
        public static Animal createAnimal(String type, String name) {
            switch (type.toLowerCase()) {
                case "dog": return new Dog(name);
                case "cat": return new Cat(name);
                default: throw new IllegalArgumentException("Unknown animal type: " + type);
            }
        }
    }
    
    private static void demonstrateReflectionAlternatives() {
        System.out.println("27. Alternatives to Reflection:");
        
        // Good: Using factory method and interfaces
        String[] animalTypes = {"dog", "cat", "dog"};
        String[] names = {"Buddy", "Whiskers", "Max"};
        
        List<Animal> animals = new ArrayList<>();
        for (int i = 0; i < animalTypes.length; i++) {
            try {
                Animal animal = AnimalFactory.createAnimal(animalTypes[i], names[i]);
                animals.add(animal);
            } catch (IllegalArgumentException e) {
                System.out.println("   Failed to create animal: " + e.getMessage());
            }
        }
        
        System.out.println("   Created animals:");
        for (Animal animal : animals) {
            animal.makeSound();
        }
        
        // Demonstrate with Service Provider Interface pattern
        Map<String, java.util.function.Function<String, Animal>> providers = new HashMap<>();
        providers.put("dog", Dog::new);
        providers.put("cat", Cat::new);
        
        System.out.println("   Using function providers:");
        Animal dynamicDog = providers.get("dog").apply("Rex");
        dynamicDog.makeSound();
        System.out.println();
    }
    
    // ===== ITEM 67: Optimize judiciously =====
    
    static class OptimizationExample {
        // Premature optimization example - overly complex
        static class OverOptimizedStringBuilder {
            private char[] buffer;
            private int count;
            private static final int INITIAL_CAPACITY = 16;
            
            public OverOptimizedStringBuilder() {
                buffer = new char[INITIAL_CAPACITY];
            }
            
            // Complex optimization that's probably unnecessary
            public OverOptimizedStringBuilder append(String str) {
                if (str == null) str = "null";
                int len = str.length();
                ensureCapacity(count + len);
                str.getChars(0, len, buffer, count);
                count += len;
                return this;
            }
            
            private void ensureCapacity(int minimumCapacity) {
                if (minimumCapacity > buffer.length) {
                    int newCapacity = (buffer.length + 1) * 2;
                    if (newCapacity < 0) {
                        newCapacity = Integer.MAX_VALUE;
                    } else if (minimumCapacity > newCapacity) {
                        newCapacity = minimumCapacity;
                    }
                    buffer = Arrays.copyOf(buffer, newCapacity);
                }
            }
            
            @Override
            public String toString() {
                return new String(buffer, 0, count);
            }
        }
        
        // Simple, clear approach - usually fast enough
        static class SimpleStringBuilder {
            private final List<String> parts = new ArrayList<>();
            
            public SimpleStringBuilder append(String str) {
                parts.add(str == null ? "null" : str);
                return this;
            }
            
            @Override
            public String toString() {
                return String.join("", parts);
            }
        }
        
        public static void measurePerformance() {
            int iterations = 10000;
            
            // Measure over-optimized version
            long start = System.nanoTime();
            OverOptimizedStringBuilder osb = new OverOptimizedStringBuilder();
            for (int i = 0; i < iterations; i++) {
                osb.append("test").append(String.valueOf(i));
            }
            String result1 = osb.toString();
            long overOptimizedTime = System.nanoTime() - start;
            
            // Measure simple version
            start = System.nanoTime();
            SimpleStringBuilder ssb = new SimpleStringBuilder();
            for (int i = 0; i < iterations; i++) {
                ssb.append("test").append(String.valueOf(i));
            }
            String result2 = ssb.toString();
            long simpleTime = System.nanoTime() - start;
            
            // Measure built-in StringBuilder
            start = System.nanoTime();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < iterations; i++) {
                sb.append("test").append(i);
            }
            String result3 = sb.toString();
            long builtInTime = System.nanoTime() - start;
            
            System.out.println("   Over-optimized: " + (overOptimizedTime / 1_000_000.0) + "ms");
            System.out.println("   Simple: " + (simpleTime / 1_000_000.0) + "ms");
            System.out.println("   Built-in StringBuilder: " + (builtInTime / 1_000_000.0) + "ms");
            System.out.println("   Results equal: " + (result1.length() == result2.length() && 
                                                      result2.length() == result3.length()));
        }
    }
    
    private static void demonstrateOptimization() {
        System.out.println("28. Judicious Optimization:");
        System.out.println("   Performance comparison (10,000 iterations):");
        OptimizationExample.measurePerformance();
        System.out.println("   Lesson: Don't optimize prematurely - measure first!");
        System.out.println();
    }
    
    // ===== ITEM 85: Prefer alternatives to Java serialization =====
    
    static class DataTransferObject {
        private final String name;
        private final int value;
        private final List<String> tags;
        
        public DataTransferObject(String name, int value, List<String> tags) {
            this.name = Objects.requireNonNull(name);
            this.value = value;
            this.tags = new ArrayList<>(Objects.requireNonNull(tags));
        }
        
        // JSON-like serialization (simple example)
        public String toJson() {
            StringBuilder json = new StringBuilder();
            json.append("{");
            json.append("\"name\":\"").append(name).append("\",");
            json.append("\"value\":").append(value).append(",");
            json.append("\"tags\":[");
            for (int i = 0; i < tags.size(); i++) {
                if (i > 0) json.append(",");
                json.append("\"").append(tags.get(i)).append("\"");
            }
            json.append("]}");
            return json.toString();
        }
        
        // Simple parsing (in real world, use a proper JSON library)
        public static DataTransferObject fromJson(String json) {
            // This is a simplified parser - use Jackson or Gson in real applications
            json = json.trim();
            if (!json.startsWith("{") || !json.endsWith("}")) {
                throw new IllegalArgumentException("Invalid JSON format");
            }
            
            // Extract name (simplified)
            String name = extractValue(json, "name");
            int value = Integer.parseInt(extractValue(json, "value"));
            
            // Extract tags (simplified)
            List<String> tags = new ArrayList<>();
            String tagsSection = json.substring(json.indexOf("\"tags\":[") + 8, json.lastIndexOf("]"));
            if (!tagsSection.trim().isEmpty()) {
                String[] tagArray = tagsSection.split(",");
                for (String tag : tagArray) {
                    tags.add(tag.trim().replaceAll("\"", ""));
                }
            }
            
            return new DataTransferObject(name, value, tags);
        }
        
        private static String extractValue(String json, String key) {
            String pattern = "\"" + key + "\":";
            int start = json.indexOf(pattern) + pattern.length();
            int end;
            
            if (json.charAt(start) == '"') {
                start++; // Skip opening quote
                end = json.indexOf('"', start);
            } else {
                end = json.indexOf(',', start);
                if (end == -1) end = json.indexOf('}', start);
            }
            
            return json.substring(start, end);
        }
        
        @Override
        public String toString() {
            return String.format("DTO{name='%s', value=%d, tags=%s}", name, value, tags);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            DataTransferObject that = (DataTransferObject) obj;
            return value == that.value &&
                   Objects.equals(name, that.name) &&
                   Objects.equals(tags, that.tags);
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(name, value, tags);
        }
    }
    
    private static void demonstrateSerializationAlternatives() {
        System.out.println("29. Serialization Alternatives:");
        
        DataTransferObject original = new DataTransferObject(
            "TestObject", 
            42, 
            Arrays.asList("tag1", "tag2", "tag3")
        );
        
        System.out.println("   Original: " + original);
        
        // JSON serialization alternative
        String json = original.toJson();
        System.out.println("   JSON: " + json);
        
        DataTransferObject deserialized = DataTransferObject.fromJson(json);
        System.out.println("   Deserialized: " + deserialized);
        System.out.println("   Objects equal: " + original.equals(deserialized));
        
        System.out.println("   Benefits: Human-readable, cross-platform, safer than Java serialization");
        System.out.println();
    }
    
    // ===== ITEM 4: Enforce noninstantiability with a private constructor =====
    
    static class MathUtilities {
        // Private constructor prevents instantiation
        private MathUtilities() {
            throw new AssertionError("Utility class should not be instantiated");
        }
        
        public static double circleArea(double radius) {
            if (radius < 0) {
                throw new IllegalArgumentException("Radius cannot be negative");
            }
            return Math.PI * radius * radius;
        }
        
        public static double circleCircumference(double radius) {
            if (radius < 0) {
                throw new IllegalArgumentException("Radius cannot be negative");
            }
            return 2 * Math.PI * radius;
        }
        
        public static boolean isPrime(int n) {
            if (n < 2) return false;
            if (n == 2) return true;
            if (n % 2 == 0) return false;
            
            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) return false;
            }
            return true;
        }
        
        public static int gcd(int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
        }
    }
    
    private static void demonstrateNoninstantiability() {
        System.out.println("30. Noninstantiable Utility Classes:");
        
        // Can use static methods
        System.out.println("   Circle area (r=5): " + String.format("%.2f", MathUtilities.circleArea(5.0)));
        System.out.println("   Is 17 prime: " + MathUtilities.isPrime(17));
        System.out.println("   GCD(48, 18): " + MathUtilities.gcd(48, 18));
        
        // Cannot instantiate
        try {
            // This would cause compilation error: MathUtilities util = new MathUtilities();
            System.out.println("   Private constructor prevents instantiation");
        } catch (Exception e) {
            System.out.println("   Exception: " + e.getMessage());
        }
        System.out.println();
    }
    
    // ===== ITEM 6: Avoid creating unnecessary objects =====
    
    static class ObjectCreationExample {
        // Bad: creates new String object unnecessarily
        private static final String BAD_CONSTANT = new String("constant");
        
        // Good: reuses string literal
        private static final String GOOD_CONSTANT = "constant";
        
        // Bad: creates new Pattern every time
        static boolean isEmailBad(String email) {
            return email.matches("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}");
        }
        
        // Good: reuses compiled Pattern
        private static final java.util.regex.Pattern EMAIL_PATTERN = 
            java.util.regex.Pattern.compile("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}");
        
        static boolean isEmailGood(String email) {
            return EMAIL_PATTERN.matcher(email).matches();
        }
        
        // Demonstrate autoboxing overhead
        public static Long sumBad() {
            Long sum = 0L; // Boxed primitive
            for (long i = 0; i < 1000000; i++) {
                sum += i; // Autoboxing creates new Long objects
            }
            return sum;
        }
        
        public static long sumGood() {
            long sum = 0L; // Primitive
            for (long i = 0; i < 1000000; i++) {
                sum += i; // No object creation
            }
            return sum;
        }
        
        // Prefer primitives to boxed primitives for better performance
        public static void demonstratePerformance() {
            long start = System.nanoTime();
            Long result1 = sumBad();
            long badTime = System.nanoTime() - start;
            
            start = System.nanoTime();
            long result2 = sumGood();
            long goodTime = System.nanoTime() - start;
            
            System.out.println("   Boxed primitive time: " + (badTime / 1_000_000.0) + "ms");
            System.out.println("   Primitive time: " + (goodTime / 1_000_000.0) + "ms");
            System.out.println("   Results equal: " + (result1.longValue() == result2));
        }
    }
    
    private static void demonstrateObjectReuse() {
        System.out.println("31. Avoiding Unnecessary Object Creation:");
        
        // String creation
        System.out.println("   Good constant: " + ObjectCreationExample.GOOD_CONSTANT);
        
        // Pattern reuse
        String email = "test@example.com";
        System.out.println("   Email valid (reused pattern): " + ObjectCreationExample.isEmailGood(email));
        
        // Performance comparison
        ObjectCreationExample.demonstratePerformance();
        System.out.println();
    }
    
    // ===== ITEM 9: Prefer try-with-resources to try-finally =====
    
    static class ResourceExample {
        // Simulate a resource that needs cleanup
        static class MockResource implements AutoCloseable {
            private final String name;
            private boolean closed = false;
            
            public MockResource(String name) {
                this.name = name;
                System.out.println("   Opening resource: " + name);
            }
            
            public void doWork() {
                if (closed) {
                    throw new IllegalStateException("Resource is closed: " + name);
                }
                System.out.println("   Working with resource: " + name);
            }
            
            @Override
            public void close() {
                if (!closed) {
                    System.out.println("   Closing resource: " + name);
                    closed = true;
                }
            }
        }
        
        // Bad: try-finally (error-prone)
        public static void badResourceHandling() throws Exception {
            MockResource resource = null;
            try {
                resource = new MockResource("bad-resource");
                resource.doWork();
                // If exception occurs here, close() might not be called
            } finally {
                if (resource != null) {
                    resource.close(); // This could throw and suppress original exception
                }
            }
        }
        
        // Good: try-with-resources (automatic cleanup)
        public static void goodResourceHandling() throws Exception {
            try (MockResource resource = new MockResource("good-resource")) {
                resource.doWork();
                // Resource automatically closed, even if exception occurs
            }
        }
        
        // Multiple resources
        public static void multipleResources() throws Exception {
            try (MockResource resource1 = new MockResource("resource-1");
                 MockResource resource2 = new MockResource("resource-2")) {
                resource1.doWork();
                resource2.doWork();
                // Both resources automatically closed in reverse order
            }
        }
    }
    
    private static void demonstrateTryWithResources() {
        System.out.println("32. Try-with-resources:");
        
        try {
            System.out.println("   Single resource:");
            ResourceExample.goodResourceHandling();
            
            System.out.println("   Multiple resources:");
            ResourceExample.multipleResources();
        } catch (Exception e) {
            System.out.println("   Exception: " + e.getMessage());
        }
        System.out.println();
    }
    
    // ===== ITEM 16: In public classes, use accessor methods, not public fields =====
    
    // Bad: public fields
    static class BadPoint {
        public double x;
        public double y;
        
        public BadPoint(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }
    
    // Good: private fields with accessors
    static class GoodPoint {
        private double x;
        private double y;
        
        public GoodPoint(double x, double y) {
            this.x = x;
            this.y = y;
        }
        
        public double getX() { return x; }
        public double getY() { return y; }
        
        public void setX(double x) {
            if (!Double.isFinite(x)) {
                throw new IllegalArgumentException("x must be finite");
            }
            this.x = x;
        }
        
        public void setY(double y) {
            if (!Double.isFinite(y)) {
                throw new IllegalArgumentException("y must be finite");
            }
            this.y = y;
        }
        
        public double distanceFromOrigin() {
            return Math.sqrt(x * x + y * y);
        }
        
        @Override
        public String toString() {
            return String.format("Point(%.1f, %.1f)", x, y);
        }
    }
    
    private static void demonstrateAccessorMethods() {
        System.out.println("33. Accessor Methods vs Public Fields:");
        
        // Bad approach allows invalid state
        BadPoint badPoint = new BadPoint(3.0, 4.0);
        badPoint.x = Double.NaN; // Can set invalid value!
        System.out.println("   Bad point allows invalid state: (" + badPoint.x + ", " + badPoint.y + ")");
        
        // Good approach validates and provides behavior
        GoodPoint goodPoint = new GoodPoint(3.0, 4.0);
        System.out.println("   Good point: " + goodPoint);
        System.out.println("   Distance from origin: " + String.format("%.1f", goodPoint.distanceFromOrigin()));
        
        try {
            goodPoint.setX(Double.NaN); // Will throw exception
        } catch (IllegalArgumentException e) {
            System.out.println("   Validation works: " + e.getMessage());
        }
        System.out.println();
    }
    
    // ===== ITEM 19: Design and document for inheritance or else prohibit it =====
    
    // Good: Designed for inheritance with hooks
    static abstract class AbstractProcessor {
        // Template method
        public final String process(String input) {
            String validated = validate(input);
            String transformed = transform(validated);
            return finalize(transformed);
        }
        
        // Hook for subclasses - documented behavior
        protected String validate(String input) {
            if (input == null || input.trim().isEmpty()) {
                throw new IllegalArgumentException("Input cannot be null or empty");
            }
            return input.trim();
        }
        
        // Abstract method that subclasses must implement
        protected abstract String transform(String input);
        
        // Hook with default behavior
        protected String finalize(String result) {
            return result;
        }
    }
    
    static class UpperCaseProcessor extends AbstractProcessor {
        @Override
        protected String transform(String input) {
            return input.toUpperCase();
        }
        
        @Override
        protected String finalize(String result) {
            return "[PROCESSED] " + result;
        }
    }
    
    // Good: Class not designed for inheritance - final
    static final class UtilityProcessor {
        public static String processText(String input) {
            if (input == null) return "";
            return input.trim().toLowerCase();
        }
    }
    
    private static void demonstrateInheritanceDesign() {
        System.out.println("34. Designing for Inheritance:");
        
        AbstractProcessor processor = new UpperCaseProcessor();
        String result = processor.process("  hello world  ");
        System.out.println("   Processed: " + result);
        
        String utilityResult = UtilityProcessor.processText("  HELLO WORLD  ");
        System.out.println("   Utility result: " + utilityResult);
        
        System.out.println("   AbstractProcessor: designed for inheritance with hooks");
        System.out.println("   UtilityProcessor: final class - inheritance prohibited");
        System.out.println();
    }
    
    // ===== ITEM 22: Use interfaces only to define types =====
    
    // Bad: constant interface antipattern
    interface BadConstants {
        double PI = 3.14159;
        int MAX_SIZE = 100;
        String DEFAULT_NAME = "Unknown";
    }
    
    // Good: use class with private constructor for constants
    static final class GoodConstants {
        private GoodConstants() {} // Prevents instantiation
        
        public static final double PI = Math.PI;
        public static final int MAX_SIZE = 100;
        public static final String DEFAULT_NAME = "Unknown";
    }
    
    // Good: interface defines a type
    interface Drawable {
        void draw();
        default void highlight() {
            System.out.println("   Highlighting drawable object");
        }
    }
    
    static class Circle implements Drawable {
        private final double radius;
        
        public Circle(double radius) {
            this.radius = radius;
        }
        
        @Override
        public void draw() {
            System.out.println("   Drawing circle with radius " + radius);
        }
    }
    
    private static void demonstrateInterfaceUsage() {
        System.out.println("35. Proper Interface Usage:");
        
        System.out.println("   Good constants: PI = " + GoodConstants.PI);
        System.out.println("   Max size: " + GoodConstants.MAX_SIZE);
        
        Drawable drawable = new Circle(5.0);
        drawable.draw();
        drawable.highlight();
        
        System.out.println("   Interfaces should define types, not just hold constants");
        System.out.println();
    }
    
    // ===== ITEM 43: Prefer method references to lambdas =====
    
    private static void demonstrateMethodReferences() {
        System.out.println("36. Method References vs Lambdas:");
        
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
        
        // Lambda expressions
        System.out.println("   Using lambdas:");
        words.stream()
             .map(s -> s.toUpperCase())
             .forEach(s -> System.out.println("     " + s));
        
        // Method references (preferred when possible)
        System.out.println("   Using method references:");
        words.stream()
             .map(String::toUpperCase)
             .forEach(System.out::println);
        
        // Static method reference
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        System.out.println("   Square roots using method reference:");
        numbers.stream()
               .map(Math::sqrt)
               .forEach(d -> System.out.println("     " + String.format("%.2f", d)));
        
        // Constructor reference
        System.out.println("   Creating points using constructor reference:");
        List<GoodPoint> points = Arrays.asList(1, 2, 3, 4)
                                      .stream()
                                      .map(i -> new GoodPoint(i, i * 2))
                                      .collect(java.util.stream.Collectors.toList());
        points.forEach(p -> System.out.println("     " + p));
        System.out.println();
    }
    
    // ===== ITEM 45: Use streams judiciously =====
    
    static class StreamExample {
        // Good use of streams: clear and concise
        public static Map<String, List<String>> groupWordsByLength(List<String> words) {
            return words.stream()
                       .collect(java.util.stream.Collectors.groupingBy(
                           word -> word.length() <= 4 ? "short" : "long"));
        }
        
        // Bad use of streams: overly complex
        public static String badStreamExample(List<String> words) {
            return words.stream()
                       .filter(w -> w.length() > 3)
                       .map(String::toUpperCase)
                       .collect(java.util.stream.Collectors.groupingBy(w -> w.charAt(0)))
                       .entrySet().stream()
                       .sorted(Map.Entry.comparingByKey())
                       .map(e -> e.getKey() + ":" + String.join(",", e.getValue()))
                       .collect(java.util.stream.Collectors.joining("|"));
        }
        
        // Better: break into smaller, readable methods
        public static String goodStreamExample(List<String> words) {
            Map<Character, List<String>> grouped = groupByFirstLetter(
                filterAndTransform(words));
            return formatGroups(grouped);
        }
        
        private static List<String> filterAndTransform(List<String> words) {
            return words.stream()
                       .filter(w -> w.length() > 3)
                       .map(String::toUpperCase)
                       .collect(java.util.stream.Collectors.toList());
        }
        
        private static Map<Character, List<String>> groupByFirstLetter(List<String> words) {
            return words.stream()
                       .collect(java.util.stream.Collectors.groupingBy(w -> w.charAt(0)));
        }
        
        private static String formatGroups(Map<Character, List<String>> groups) {
            return groups.entrySet().stream()
                        .sorted(Map.Entry.comparingByKey())
                        .map(e -> e.getKey() + ":" + String.join(",", e.getValue()))
                        .collect(java.util.stream.Collectors.joining("|"));
        }
    }
    
    private static void demonstrateStreamUsage() {
        System.out.println("37. Judicious Stream Usage:");
        
        List<String> words = Arrays.asList("cat", "elephant", "dog", "butterfly", "ant", "hippopotamus");
        
        // Good: simple and clear
        Map<String, List<String>> grouped = StreamExample.groupWordsByLength(words);
        System.out.println("   Grouped by length: " + grouped);
        
        // Complex example
        String result = StreamExample.goodStreamExample(words);
        System.out.println("   Formatted groups: " + result);
        
        System.out.println("   Key: Use streams for simple transformations, not complex logic");
        System.out.println();
    }
    
    // ===== ITEM 58: Prefer for-each loops to traditional for loops =====
    
    private static void demonstrateForEachLoops() {
        System.out.println("38. For-each Loops:");
        
        List<String> fruits = Arrays.asList("apple", "banana", "cherry");
        int[] numbers = {1, 2, 3, 4, 5};
        
        // Good: for-each loop (enhanced for loop)
        System.out.println("   Fruits using for-each:");
        for (String fruit : fruits) {
            System.out.println("     " + fruit);
        }
        
        System.out.println("   Numbers using for-each:");
        for (int number : numbers) {
            System.out.println("     " + number * number);
        }
        
        // When traditional for loop is needed
        System.out.println("   When you need the index (traditional for):");
        for (int i = 0; i < fruits.size(); i++) {
            System.out.println("     " + i + ": " + fruits.get(i));
        }
        
        // Nested loops benefit greatly from for-each
        System.out.println("   Nested for-each loops:");
        List<String> colors = Arrays.asList("red", "blue");
        for (String fruit : fruits) {
            for (String color : colors) {
                if (Math.random() > 0.7) { // Just to limit output
                    System.out.println("     " + color + " " + fruit);
                }
            }
        }
        System.out.println();
    }
    
    // ===== ITEM 69: Use exceptions only for exceptional conditions =====
    
    static class ExceptionExample {
        // Bad: using exception for control flow
        public static void badArrayIteration(int[] array) {
            try {
                int i = 0;
                while (true) {
                    System.out.println("     " + array[i++]);
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                // Using exception to terminate loop - BAD!
            }
        }
        
        // Good: normal control flow
        public static void goodArrayIteration(int[] array) {
            for (int i = 0; i < array.length; i++) {
                System.out.println("     " + array[i]);
            }
        }
        
        // Even better: for-each loop
        public static void bestArrayIteration(int[] array) {
            for (int value : array) {
                System.out.println("     " + value);
            }
        }
        
        // Good: exception for truly exceptional condition
        public static double safeDivide(double a, double b) {
            if (b == 0.0) {
                throw new IllegalArgumentException("Division by zero");
            }
            return a / b;
        }
        
        // Good: state-testing method to avoid exceptions
        static class SafeIterator<T> {
            private final List<T> items;
            private int position = 0;
            
            public SafeIterator(List<T> items) {
                this.items = new ArrayList<>(items);
            }
            
            public boolean hasNext() {
                return position < items.size();
            }
            
            public T next() {
                if (!hasNext()) {
                    throw new IllegalStateException("No more elements");
                }
                return items.get(position++);
            }
        }
    }
    
    private static void demonstrateExceptionUsage() {
        System.out.println("39. Proper Exception Usage:");
        
        int[] array = {1, 2, 3, 4, 5};
        
        System.out.println("   Good array iteration:");
        ExceptionExample.bestArrayIteration(array);
        
        // Exception for exceptional condition
        try {
            double result = ExceptionExample.safeDivide(10.0, 0.0);
            System.out.println("   Result: " + result);
        } catch (IllegalArgumentException e) {
            System.out.println("   Caught expected exception: " + e.getMessage());
        }
        
        // State-testing method
        System.out.println("   Safe iterator:");
        ExceptionExample.SafeIterator<String> iterator = 
            new ExceptionExample.SafeIterator<>(Arrays.asList("a", "b", "c"));
        
        while (iterator.hasNext()) {
            System.out.println("     " + iterator.next());
        }
        
        System.out.println("   Key: Exceptions are for exceptional conditions, not normal control flow");
        System.out.println();
        
        // Final summary
        printSummary();
    }
    
    private static void printSummary() {
        System.out.println("=== EFFECTIVE JAVA PRINCIPLES SUMMARY ===");
        System.out.println();
        System.out.println("Key Categories Demonstrated:");
        System.out.println();
        
        System.out.println("OBJECT CREATION & DESTRUCTION:");
        System.out.println("• Static factory methods provide clear names and flexibility");
        System.out.println("• Builder pattern handles complex object construction");
        System.out.println("• Enum singletons are the best singleton implementation");
        System.out.println("• Use try-with-resources instead of finalizers");
        System.out.println();
        
        System.out.println("METHODS COMMON TO ALL OBJECTS:");
        System.out.println("• Override equals() and hashCode() together, following contracts");
        System.out.println("• Prefer copy constructors over clone()");
        System.out.println("• Make defensive copies of mutable components");
        System.out.println();
        
        System.out.println("CLASSES AND INTERFACES:");
        System.out.println("• Minimize accessibility - use private/package-private when possible");
        System.out.println("• Favor composition over inheritance");
        System.out.println("• Prefer interfaces to abstract classes");
        System.out.println("• Design immutable classes when possible");
        System.out.println();
        
        System.out.println("GENERICS:");
        System.out.println("• Don't use raw types - always parameterize");
        System.out.println("• Use generic methods for type safety");
        System.out.println("• Consider typesafe heterogeneous containers");
        System.out.println();
        
        System.out.println("METHODS:");
        System.out.println("• Check parameters for validity early");
        System.out.println("• Use overloading judiciously - prefer distinct names");
        System.out.println("• Return Collections instead of Streams for flexibility");
        System.out.println();
        
        System.out.println("GENERAL PROGRAMMING:");
        System.out.println("• Minimize scope of local variables");
        System.out.println("• Prefer primitive types to boxed primitives");
        System.out.println("• Avoid strings where other types are more appropriate");
        System.out.println("• Refer to objects by their interfaces");
        System.out.println();
        
        System.out.println("CONCURRENCY:");
        System.out.println("• Synchronize access to shared mutable data");
        System.out.println("• Prefer concurrency utilities to wait/notify");
        System.out.println("• Use thread-safe collections when appropriate");
        System.out.println();
        
        System.out.println("PERFORMANCE & OPTIMIZATION:");
        System.out.println("• Optimize judiciously - measure before optimizing");
        System.out.println("• Prefer interfaces to reflection for flexibility");
        System.out.println("• Simple, clear code often performs well enough");
        System.out.println();
        
        System.out.println("SERIALIZATION:");
        System.out.println("• Consider serialization proxies for safety");
        System.out.println("• Prefer alternatives like JSON to Java serialization");
        System.out.println("• Design serialization carefully to maintain invariants");
        System.out.println();
        
        System.out.println("OVERALL PHILOSOPHY:");
        System.out.println("• Favor clarity over cleverness");
        System.out.println("• Design for safety and maintainability");
        System.out.println("• Follow established conventions and contracts");
        System.out.println("• Write code that's easy to understand and modify");
        System.out.println();
        
        System.out.println("=== END OF EFFECTIVE JAVA EXAMPLES ===");
    }
}
